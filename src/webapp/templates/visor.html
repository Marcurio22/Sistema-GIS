{% extends "base.html" %}

{% block title %}Visor SIG{% endblock %}

{% block navbar_extra %}
<div class="d-none d-md-flex align-items-center gap-3 bg-white rounded-3 px-3 py-2 shadow-sm">
  <!-- Temperatura principal -->
  <div class="d-flex align-items-center">
    <i class="bi bi-{{ weather.icono }} {{ weather.color_icono }}" style="font-size: 1.5rem;"></i>
    <span class="ms-2 fw-bold fs-5 text-dark">{{ weather.temperatura }}°</span>
  </div>

  <!-- Separador -->
  <div class="vr opacity-50"></div>

  <!-- Datos compactos -->
  <div class="d-flex gap-3 small text-dark">
    {% if weather.humedad %}
    <div class="d-flex align-items-center">
      <i class="bi bi-droplet-fill text-info me-1"></i>
      <span>{{ weather.humedad }}%</span>
    </div>
    {% endif %}

    {% if weather.viento_velocidad %}
    <div class="d-flex align-items-center">
      <i class="bi bi-wind text-secondary me-1"></i>
      <span>{{ weather.viento_velocidad }} km/h</span>
    </div>
    {% endif %}

    {% if weather.prob_precipitacion %}
    <div class="d-flex align-items-center">
      <i class="bi bi-cloud-rain text-primary me-1"></i>
      <span>{{ weather.prob_precipitacion }}%</span>
    </div>
    {% endif %}
  </div>

  <div class="d-none d-lg-block text-muted small">
    <i class="bi bi-geo-alt-fill"></i> {{ weather.municipio }}
  </div>
</div>
<div id="notification-container"></div>
<div id="lightbox" class="lightbox" style="display: none;">
  <span class="lightbox-close">&times;</span>
  <img class="lightbox-content" id="lightbox-img">
  <div class="lightbox-caption" id="lightbox-caption"></div>
  <button class="lightbox-prev" id="lightbox-prev">&#10094;</button>
  <button class="lightbox-next" id="lightbox-next">&#10095;</button>
</div>
{% endblock %}

{% block content %}


<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
<link rel="stylesheet" href="{{ url_for('static', filename='css/visor.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/galeria.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/ndvi.css') }}">
<script src="{{ url_for('static', filename='js/lightbox-manager.js') }}"></script>
<script src="{{ url_for('static', filename='js/galeria.js') }}"></script>
<script src="{{ url_for('static', filename='js/ndvi.js') }}"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>


<div id="map"></div>

<!-- Botón de capas -->
<div id="basemap-panel-container">
  <button id="basemap-toggle" title="Capas">
    <i class="bi bi-layers-fill"></i>
  </button>
</div>

<!-- Panel de capas -->
<div id="basemap-panel">
  <h6>Mapa Principal</h6>
  <div class="basemap-grid">
    <div class="basemap-option basemap-main active" data-layer="satellite">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_satellite.png') }}" alt="Imagen satélite" />
      </div>
      <div class="basemap-option-label">Imagen Satelital<br>(OSM Standard)</div>
    </div>

    <div class="basemap-option basemap-main {% if sentinel2_version == 0 %}disabled{% endif %}" data-layer="sentinel_recent">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_sentinel2.png') }}" alt="Sentinel-2 reciente" />
      </div>
      <div class="basemap-option-label">Satélite más reciente<br>(Sentinel-2)</div>
    </div>

    <div class="basemap-option basemap-main" data-layer="ndvi">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_ndvi.png') }}" alt="Vigor Vegetal (NDVI)" />
      </div>
      <div class="basemap-option-label">Vigor Vegetal<br>(NDVI)</div>
    </div>

    <div class="basemap-option disabled">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_etp.png') }}" alt="ETP" />
      </div>
      <div class="basemap-option-label">ETP</div>
    </div>
  </div>

  <h6>Nivel de Detalle</h6>
  <div class="basemap-grid">
    <div class="basemap-option basemap-detail active" data-detail="mis">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_mis_recintos.png') }}" alt="Mis Recintos" />
      </div>
      <div class="basemap-option-label">Mis Recintos</div>
    </div>

    <div class="basemap-option basemap-detail active" data-detail="sigpac">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_recintos.png') }}" alt="Recintos SigPac" />
      </div>
      <div class="basemap-option-label">Recintos SigPac</div>
    </div>

    <div class="basemap-option basemap-detail" data-detail="cultivosSigpac">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_cultivos.png') }}" alt="Cultivos SigPac" />
      </div>
      <div class="basemap-option-label">Cultivos SigPac</div>
    </div>

    <div class="basemap-option basemap-detail" data-detail="catastro">
        <div class="basemap-thumb">
          <img src="{{ url_for('static', filename='img/catastro.png') }}" alt="Parcelas Catastro" />
        </div>
        <div class="basemap-option-label">Parcelas Catastro</div>
      </div>
    </div>
  </div>
</div>


<!-- Botón de filtros -->
<div id="filtro-container">
  <button id="filtro-toggle" title="Filtros">
    <i class="bi bi-funnel-fill"></i>
  </button>
</div>

<!-- Botón de dibujar -->
<div id="editar-container">
  <button id="dibujar-btn" class="hidden" title="Dibujar Rectángulo">
    <i class="bi bi-square"></i>
  </button>
  <button id="poligono-btn" class="hidden" title="Dibujar Polígono">
    <i class="bi bi-pentagon"></i>
  </button>
  <button id="editar-btn" title="Editar">
    <i class="bi bi-pencil-fill"></i>
  </button>
  <button id="aceptar-btn" class="hidden" title="Aceptar">
    <i class="bi bi-check-lg"></i>
  </button>
  <button id="limpiar-btn" class="hidden" title="Limpiar todo">
    <i class="bi bi-trash-fill"></i>
  </button>
  <button id="cancelar-btn" class="hidden" title="Cancelar">
    <i class="bi bi-x-lg"></i>
  </button>
</div>


<!-- Dibujos guardados-->

<div id="dibujos-panel-container">
  <button id="dibujos-toggle" title="Mis Consultas NDVI">
    <i class="bi bi-bookmark-fill"></i>
    <span id="dibujos-count" class="badge-count" style="display:none;">0</span>
  </button>
</div>

<div id="dibujos-panel" class="hidden">
  <div class="dibujos-header">
  <h6><i class="bi bi-bookmark-fill me-2"></i>Mis Consultas NDVI</h6>
</div>
  
  <div id="dibujos-list" class="dibujos-list"></div>
</div>

<!-- Panel derecho (split) -->
<aside id="side-panel" aria-hidden="true">

  <div class="side-content">
    <div class="side-sticky-top">
      <div class="side-header">
        <h1 id="side-title">Nombre Parcela</h1>

        <div class="side-actions">
          <button id="btn-edit-name" type="button" class="icon-btn edit" title="Editar nombre">
            <i class="bi bi-pencil-fill"></i>
          </button>
          <button id="btn-delete-recinto" type="button" class="icon-btn delete" title="Eliminar recinto">
            <i class="bi bi-trash-fill"></i>
          </button>       
          <button id="side-close" type="button" class="btn-side-close" title="Cerrar">
            <i class="bi bi-x-lg"></i>
          </button>
        </div>
      </div>

      <div class="side-divider"></div>
    </div>

    <div class="side-row">
      <i class="bi bi-globe2 side-ico"></i>

      <div class="side-line" style="display:flex;align-items:center;width:100%;">
        <span class="side-row-title">Superficie:</span>
        <span id="side-area" class="side-row-value ms-2">-</span>

        <!-- Icono localización decorativo a la derecha -->
        <i class="bi bi-geo-alt-fill ms-auto text-success" style="font-size:1.6rem" aria-hidden="true">
        </i>

        <!-- Coordenadas -->
        <span id="side-coords" class="side-row-value ms-2"></span>
      </div>
    </div>

    <div class="side-row">
      <i class="bi bi-person-fill side-ico"></i>
      <div class="side-row-text">
        <div class="side-row-title">Propietario:</div>
        <div id="side-owner" class="side-row-value">-</div>
      </div>
    </div>

    <label class="side-toggle">
      <input id="side-active" type="checkbox" checked />
      <span>Recinto activo</span>
    </label>
    <div class="side-divider"></div>

   <div class="side-section">
      <div class="side-section-head">
        <div></div>
    
        <h2 class="side-section-title mb-4">
          <i class="fa-solid fa-wheat-awn me-2" style="color:#198754"></i>
          <span class="side-section-label">Cultivos</span>
        </h2>
    
        <button id="btn-historico-cultivos" type="button" class="btn btn-success btn-historico">
          Histórico de cultivos
        </button>
      </div>
    
      <div id="cultivos-container"></div>
    </div>

    <div class="side-divider"></div>

    <!-- SECCIÓN NDVI -->
    <div class="side-section">
      <div class="side-section-head">
        <div></div>
    
        <h2 class="side-section-title mb-4">
          <i class="fa-solid fa-leaf me-2" style="color:#198754"></i>
          <span class="side-section-label">NDVI</span>
        </h2>
    
        <button id="btn-detalle-ndvi" type="button" class="btn btn-success btn-historico">
          Más detalle
        </button>
      </div>
    
      <div id="ndvi-container"></div>
    </div>

    <div class="side-divider"></div>

    <!-- OPERACIONES -->
    <div class="side-section" id="operaciones-section">
      <div class="side-section-head">
        <div></div>

        <h2 class="side-section-title mb-4">
          <i class="fa-solid fa-chart-line me-2" style="color:#198754"></i>
          <span class="side-section-label">Operaciones</span>
        </h2>

        <button id="btn-historico-operaciones" class="btn btn-outline-success btn-sm ms-auto">
          <i class="bi bi-clock-history me-1"></i> Ver histórico
        </button>
      </div>

      <div id="operaciones-container"></div>
    </div>

    <div class="side-divider"></div>

    <!-- OVERLAY HISTÓRICO OPERACIONES -->
    <div id="operaciones-historico-panel" class="side-overlay d-none" aria-hidden="true">
      <div class="overlay-topbar">
        <button id="btn-volver-operaciones-historico" class="btn btn-outline-secondary" type="button">
          <i class="bi bi-arrow-left me-1"></i> Volver
        </button>

        <div class="overlay-title">
          <i class="fa-solid fa-chart-line" style="color:#198754"></i>
          <span>Operaciones</span>
        </div>

        <button id="btn-cerrar-operaciones-historico" class="btn-side-close" type="button" title="Cerrar">
          <i class="bi bi-x-lg"></i>
        </button>
      </div>

      <div class="side-divider"></div>
      <div id="operaciones-historico-list" class="pb-3"></div>
    </div>
    
    <!-- GALERÍA-->
    <div id="galeria-imagenes" class="galeria-container mt-4">
      <h2 class="side-section-title mb-3">
        <i class="fa-solid fa-image me-2" style="color:#198754"></i>
        Galería
      </h2>

      <!-- Botón Añadir Imagen -->
      <div class="mb-3">
        <button type="button" class="btn btn-success" data-bs-toggle="modal" data-bs-target="#modalSubida">
          <i class="fa-solid fa-plus me-1"></i> Añadir Imagen
        </button>
      </div>

      <!-- Grid de imágenes -->
      <div class="galeria-grid" id="galeria-grid">
        <!-- Se llenará dinámicamente -->
      </div>

    </div>

    <!-- OVERLAY HISTÓRICO CULTIVOS -->
    <div id="cultivos-historico-panel" class="side-overlay d-none" aria-hidden="true">

      <div class="overlay-topbar">
        <button id="btn-volver-historico" class="btn btn-outline-secondary" type="button">
          <i class="bi bi-arrow-left me-1"></i> Volver
        </button>

        <div class="overlay-title">
          <i class="fa-solid fa-wheat-awn" style="color:#198754"></i>
          <span>Cultivos</span>
        </div>

        <button id="btn-cerrar-historico" class="btn-side-close" type="button" title="Cerrar">
          <i class="bi bi-x-lg"></i>
        </button>
      </div>

      <div class="side-divider"></div>
      <div id="cultivos-historico-list" class="pb-3"></div>
    </div>

    <!-- OVERLAY HISTÓRICO NDVI -->
    <div id="ndvi-historico-panel" class="side-overlay d-none" aria-hidden="true">

      <div class="overlay-topbar">
        <button id="btn-volver-historico-ndvi" class="btn btn-outline-secondary" type="button">
          <i class="bi bi-arrow-left me-1"></i> Volver
        </button>

        <div class="overlay-title">
          <i class="fa-solid fa-leaf" style="color:#198754"></i>
          <span>NDVI</span>
        </div>

        <button id="btn-cerrar-historico-ndvi" class="btn-side-close" type="button" title="Cerrar">
          <i class="bi bi-x-lg"></i>
        </button>
      </div>

      <div class="side-divider"></div>
      <div id="ndvi-historico-list" class="pb-3"></div>
    </div>

    <!-- OVERLAY GALERÍA COMPLETA -->
    <div id="galeria-panel" class="side-overlay d-none" aria-hidden="true">
      <div class="overlay-topbar">
        <button id="btn-volver-galeria" class="btn btn-outline-secondary" type="button">
          <i class="bi bi-arrow-left me-1"></i> Volver
        </button>

        <div class="overlay-title">
          <i class="fa-solid fa-image" style="color:#198754"></i>
          <span>Galería</span>
        </div>

        <button id="btn-cerrar-galeria" class="btn-side-close" type="button" title="Cerrar">
          <i class="bi bi-x-lg"></i>
        </button>
      </div>

      <div class="side-divider"></div>
      <div class="overlay-subbar">
        <div class="overlay-subtitle">
          Galería completa
          <span id="galeria-count" class="badge bg-success ms-2">0</span>
        </div>
      </div>

      <div id="galeria-panel-body"></div>
    </div>

    <div id="side-alerts"></div>
  </div>



</aside>

<!-- Modal confirmación -->
<div id="app-confirm-backdrop" class="app-confirm-backdrop d-none" aria-hidden="true">
  <div class="app-confirm-modal" role="dialog" aria-modal="true" aria-labelledby="app-confirm-title">
    <div class="app-confirm-header">
      <i class="bi bi-exclamation-triangle-fill" style="font-size:28px; color:#ffc107;"></i>
      <div>
        <div id="app-confirm-title" class="app-confirm-title">Confirmación</div>
        <div id="app-confirm-text" class="app-confirm-text"></div>
      </div>
    </div>

    <div class="app-confirm-actions">
      <button id="app-confirm-cancel" type="button" class="btn btn-secondary">Cancelar</button>
      <button id="app-confirm-ok" type="button" class="btn btn-danger">Eliminar</button>
    </div>
  </div>
</div>

<!-- Modal para subir nueva imagen -->
<div class="modal fade" id="modalSubida" tabindex="-1" aria-labelledby="modalSubidaLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <form id="form-subida" enctype="multipart/form-data">
        <div class="modal-header">
          <h5 class="modal-title" id="modalSubidaLabel">Subir Nueva Imagen</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Cerrar"></button>
        </div>
        <div class="modal-body">
          <div class="mb-3">
            <label for="imagen-file" class="form-label">Selecciona Imagen</label>
            <input class="form-control" type="file" id="imagen-file" accept="image/*" required>
          </div>
          <div class="mb-3">
            <label for="imagen-titulo" class="form-label">Título</label>
            <input type="text" class="form-control" id="imagen-titulo" required>
          </div>
          <div class="mb-3">
            <label for="imagen-descripcion" class="form-label">Descripción</label>
            <textarea class="form-control" id="imagen-descripcion" rows="3"></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
          <button type="submit" class="btn btn-success">Subir Imagen</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Modal para editar imagen -->
<div class="modal fade" id="modalEditar" tabindex="-1" aria-labelledby="modalEditarLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <form id="form-editar">
        <div class="modal-header">
          <h5 class="modal-title" id="modalEditarLabel">Editar Imagen</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Cerrar"></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="editar-id-imagen">
          
           <div class="mb-3 text-center">
            <img id="editar-preview" 
                 src="" 
                 alt="Preview" 
                 style="max-width: 200px; max-height: 200px; border-radius: 8px; object-fit: cover; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
          </div>
          <div class="mb-3">
            <label for="editar-titulo" class="form-label">Título</label>
            <input type="text" class="form-control" id="editar-titulo" required>
          </div>
          
          <div class="mb-3">
            <label for="editar-descripcion" class="form-label">Descripción</label>
            <textarea class="form-control" id="editar-descripcion" rows="3"></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
          <button type="submit" class="btn btn-success">Guardar cambios</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Modal Avanzado Cultivo -->
<div class="modal fade" id="modalAvanzadoCultivo" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Avanzado (cultivo)</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Cerrar"></button>
      </div>
      <div class="modal-body" id="modalAvanzadoCultivoBody">
        <!-- contenido dinámico -->
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal Motivo Eliminación Recinto -->
<div class="modal fade" id="motivoEliminacionModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">
          <i class="bi bi-exclamation-triangle text-warning me-2"></i>
          Solicitar eliminación de recinto
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Cerrar"></button>
      </div>

      <div class="modal-body">
        <p class="mb-3">
          ¿Estás seguro de que deseas solicitar la eliminación de este recinto?
          Un administrador deberá aprobar la solicitud antes de que el recinto sea eliminado.
        </p>

        <label for="motivoEliminacionInput" class="form-label fw-bold">
          Motivo de eliminación <span class="text-danger">*</span>
        </label>

        <textarea id="motivoEliminacionInput"
                  class="form-control"
                  rows="4"
                  maxlength="500"
                  placeholder="Explica brevemente por qué solicitas la eliminación..."
                  required></textarea>

        <div class="invalid-feedback">
          Debes indicar un motivo.
        </div>

        <small class="text-muted d-block mt-2">Máximo 500 caracteres.</small>
      </div>

      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
        <button type="button" class="btn btn-danger" id="btnConfirmarMotivoEliminacion">
          Solicitar eliminación
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Script general -->
<script>
  const NotificationSystem = {
    container: null,
    initialized: false,

    init() {
      if (this.initialized) return;

      this.container = document.getElementById('notification-container');

      if (!this.container) {
        // Crear el contenedor si no existe
        this.container = document.createElement('div');
        this.container.id = 'notification-container';
        document.body.appendChild(this.container);
      
      } else {
      }
      this.initialized = true;
    },

    show({ type = 'info', title, message, duration = 5000 }) {
      // Inicializar si no está listo
      if (!this.initialized) {
        this.init();
      }

      if (!this.container) {
        alert(`${title}\n${message}`);
        return;
      }

      const notification = document.createElement('div');
      notification.className = `notification ${type}`;

      const icons = {
        success: '✓',
        error: '✕',
        warning: '⚠',
        info: 'i'
      };

      notification.innerHTML = `
        <div class="notification-icon">${icons[type]}</div>
        <div class="notification-content">
          <div class="notification-title">${this.escapeHtml(title)}</div>
          <div class="notification-message">${this.escapeHtml(message)}</div>
        </div>
        <button class="notification-close" aria-label="Cerrar">×</button>
        <div class="notification-progress"></div>
      `;

      // Evento de cierre
      const closeBtn = notification.querySelector('.notification-close');
      closeBtn.addEventListener('click', () => this.close(closeBtn));

      this.container.appendChild(notification);

      // Auto-cierre
      if (duration > 0) {
        setTimeout(() => {
          this.close(closeBtn);
        }, duration);
      }
    },

    close(button) {
      const notification = button.closest('.notification');
      if (!notification) return;

      notification.classList.add('removing');
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 300);
    },

    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };

  // Función para establecer la variable CSS con la altura de la navbar
  function setNavbarHeightVar() {
    const candidates = [
      'nav.navbar.fixed-top',
      'nav.navbar.sticky-top',
      '.navbar.fixed-top',
      '.navbar.sticky-top',
      'header.fixed-top',
      'header.sticky-top',
      'nav'
    ];

    let el = null;
    for (const sel of candidates) {
      const found = document.querySelector(sel);
      if (!found) continue;

      const cs = window.getComputedStyle(found);
      const pos = cs.position;
      if (pos === 'fixed' || pos === 'sticky') {
        el = found;
        break;
      }
    }

    let h = 65;
    if (el) {
      const rect = el.getBoundingClientRect();
      h = Math.round(rect.bottom);
    }

    if (h < 40 || h > 120) h = 65;
    document.documentElement.style.setProperty('--navbar-h', `${h}px`);
  }

  // calcular al cargar
  setNavbarHeightVar();
  // recalcular por si cambia (responsive)
  window.addEventListener("resize", setNavbarHeightVar);

  const AppConfirm = (() => {
    let backdrop, titleEl, textEl, btnOk, btnCancel;
    let resolveFn = null;
    let escHandler = null;

    function ensure() {
      if (backdrop) return;
      backdrop = document.getElementById("app-confirm-backdrop");
      titleEl = document.getElementById("app-confirm-title");
      textEl = document.getElementById("app-confirm-text");
      btnOk = document.getElementById("app-confirm-ok");
      btnCancel = document.getElementById("app-confirm-cancel");

      // No cerrar al clicar fuera
      backdrop.addEventListener("click", (e) => {
        if (e.target === backdrop) {
          e.preventDefault();
          e.stopPropagation();
        }
      });

      btnCancel.addEventListener("click", () => close(false));
      btnOk.addEventListener("click", () => close(true));
    }

    function open({ title, message, okText = "Aceptar", cancelText = "Cancelar", okClass = "btn-danger" }) {
      ensure();

      titleEl.textContent = title || "Confirmación";
      textEl.textContent = message || "";
      btnOk.textContent = okText;
      btnCancel.textContent = cancelText;

      btnOk.className = `btn ${okClass}`;

      backdrop.classList.remove("d-none");
      backdrop.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";

      // No cerrar con ESC
      escHandler = (e) => {
        if (e.key === "Escape") {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      document.addEventListener("keydown", escHandler, true);

      return new Promise((resolve) => {
        resolveFn = resolve;
        setTimeout(() => btnOk.focus(), 0);
      });
    }

    function close(result) {
      if (!backdrop) return;

      backdrop.classList.add("d-none");
      backdrop.setAttribute("aria-hidden", "true");
      document.body.style.overflow = "";

      if (escHandler) {
        document.removeEventListener("keydown", escHandler, true);
        escHandler = null;
      }

      const r = resolveFn;
      resolveFn = null;
      r?.(!!result);
    }

    return { open };
  })();

  function openMotivoEliminacionModal() {
  return new Promise((resolve) => {
    const modalEl = document.getElementById("motivoEliminacionModal");
    const inputEl = document.getElementById("motivoEliminacionInput");
    const btnOk = document.getElementById("btnConfirmarMotivoEliminacion");

    if (!modalEl || !inputEl || !btnOk) {
      console.error("Faltan elementos del modal de motivo de eliminación");
      resolve(null);
      return;
    }

    // Bootstrap modal instance
    const modal = bootstrap.Modal.getOrCreateInstance(modalEl, {
      backdrop: "static", // no cerrar clic fuera
      keyboard: false     // no cerrar con ESC
    });

    // Estado inicial
    inputEl.value = "";
    inputEl.classList.remove("is-invalid");

    let settled = false;

    const cleanup = () => {
      btnOk.removeEventListener("click", onOk);
      modalEl.removeEventListener("hidden.bs.modal", onHidden);
      inputEl.removeEventListener("keydown", onKeyDown);
    };

    const finish = (val) => {
      if (settled) return;
      settled = true;
      cleanup();
      resolve(val);
    };

    const onOk = () => {
      const motivo = (inputEl.value || "").trim();

      if (!motivo) {
        inputEl.classList.add("is-invalid");
        inputEl.focus();
        return;
      }

      modal.hide();
      finish(motivo);
    };

    // Si se cierra por cancelar (btn-close o btn-secondary), devolver null
    const onHidden = () => {
      if (!settled) finish(null);
    };

    // Enter envía (Shift+Enter hace salto de línea)
    const onKeyDown = (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        btnOk.click();
      }
    };

    btnOk.addEventListener("click", onOk);
    modalEl.addEventListener("hidden.bs.modal", onHidden);
    inputEl.addEventListener("keydown", onKeyDown);

    modal.show();

    // foco al mostrar
    setTimeout(() => inputEl.focus(), 150);
  });
}

  // -----------------------------------------
  // DOM Content Loaded
  // -----------------------------------------
  document.addEventListener("DOMContentLoaded", function () {
    function guardarEstadoMapa() {
  const estado = {
    zoom: map.getZoom(),
    center: map.getCenter(),
    sidePanelAbierto: splitOpen,
    recintoActual: currentSideRecintoId,
    timestamp: Date.now()
  };
  
  try {
    sessionStorage.setItem('mapaEstado', JSON.stringify(estado));
  } catch (e) {
    console.warn('No se pudo guardar el estado del mapa:', e);
  }
}

// Función para restaurar el estado del mapa y panel
async function restaurarEstadoMapa() {
  try {
    const estadoStr = sessionStorage.getItem('mapaEstado');
    if (!estadoStr) return false;
    
    const estado = JSON.parse(estadoStr);
    
    // Verificar que no sea muy antiguo (opcional, 30 minutos)
    const tiempoMaximo = 30 * 60 * 1000; // 30 minutos
    if (Date.now() - estado.timestamp > tiempoMaximo) {
      sessionStorage.removeItem('mapaEstado');
      return false;
    }
    
    // Restaurar vista del mapa
    if (estado.center && estado.zoom) {
      map.setView([estado.center.lat, estado.center.lng], estado.zoom);
    }
    
    // Restaurar side panel si estaba abierto
    if (estado.sidePanelAbierto && estado.recintoActual) {
      // Esperar un poco a que el mapa se estabilice
      await new Promise(resolve => setTimeout(resolve, 500));
      
      try {
        // Intentar cargar los datos del recinto
        const response = await fetch(`/api/mis-recinto/${estado.recintoActual}`);
        if (!response.ok) throw new Error('Recinto no encontrado');
        
        const data = await response.json();
        
        // Abrir el panel con los datos
        abrirRecintoEnPanel(data);
        
        console.log('Estado del mapa restaurado correctamente');
        return true;
      } catch (err) {
        console.warn('No se pudo restaurar el recinto:', err);
        sessionStorage.removeItem('mapaEstado');
        return false;
      }
    }
    
    return true;
  } catch (e) {
    console.warn('Error al restaurar estado del mapa:', e);
    sessionStorage.removeItem('mapaEstado');
    return false;
  }
}

// Vista inicial recomendada: centrar en el municipio donde el usuario tiene MÁS "mis recintos"
// - Si no hay datos (o el usuario es admin), devuelve false y se mantiene el fallback actual.
async function aplicarVistaInicialUsuario() {
  try {
    const resp = await fetch('/api/visor-start-view', { credentials: 'same-origin' });
    if (!resp.ok) return false;

    const data = await resp.json();
    if (!data) return false;

    // bbox: [minx, miny, maxx, maxy] -> Leaflet bounds [[miny, minx],[maxy, maxx]]
    if (data.bbox && Array.isArray(data.bbox) && data.bbox.length === 4) {
      const [minx, miny, maxx, maxy] = data.bbox;
      if ([minx, miny, maxx, maxy].every(v => typeof v === 'number' && isFinite(v))) {
        map.fitBounds([[miny, minx], [maxy, maxx]], {
          padding: [80, 80],
          maxZoom: 16,
          animate: true,
          duration: 0.35
        });
        return true;
      }
    }

    // center fallback
    if (data.center && typeof data.center.lat === 'number' && typeof data.center.lng === 'number') {
      const z = (typeof data.zoom_sugerido === 'number' && isFinite(data.zoom_sugerido)) ? data.zoom_sugerido : 13;
      map.setView([data.center.lat, data.center.lng], z);
      return true;
    }

    return false;
  } catch (e) {
    console.warn('No se pudo aplicar vista inicial del usuario:', e);
    return false;
  }
}

  const CURRENT_USER_ID = {{ current_user.id_usuario if current_user.is_authenticated else 'null' }};
  NotificationSystem.init();

  // -----------------------------------------
  // 1) ROI desde Flask
  // -----------------------------------------
  const roiBbox = [
    {{ roi_bbox[0] }},
    {{ roi_bbox[1] }},
    {{ roi_bbox[2] }},
    {{ roi_bbox[3] }}
  ];

  const ROI_BOUNDS = L.latLngBounds(
    [roiBbox[1], roiBbox[0]],
    [roiBbox[3], roiBbox[2]]
  );

  const S2_BOUNDS = L.latLngBounds({{ s2_bounds | tojson | safe }});

  const NDVI_BOUNDS = L.latLngBounds({{ ndvi_bounds | tojson | safe }});

  const ZOOM_RECINTOS = 15;

  // -----------------------------------------
  // 2) Crear mapa
  // -----------------------------------------
  const map = L.map("map", {
    maxBounds: ROI_BOUNDS,
    maxBoundsViscosity: 1.0,
    zoomControl: true,
  });

  map.fitBounds(ROI_BOUNDS);


  

  // --- Panes (orden de dibujo) ---
  map.createPane('sigpacPane');
  map.getPane('sigpacPane').style.zIndex = 400;

  map.createPane('misPane');
  map.getPane('misPane').style.zIndex = 450;

  map.createPane('highlightPane');
  map.getPane('highlightPane').style.zIndex = 650;

  map.createPane("cultivosSigpacPane");
  map.getPane("cultivosSigpacPane").style.zIndex = 440;

  map.createPane("catastroPane");
  map.getPane("catastroPane").style.zIndex = 430;

  // --- Modo split (panel derecho vacío) ---
  let splitOpen = false;

  function setSplitMode(on) {
  splitOpen = !!on;

  if (splitOpen) {
    setNavbarHeightVar();
  }

  document.body.classList.toggle("split-mode", splitOpen);

  const sp = document.getElementById("side-panel");
  if (sp) sp.setAttribute("aria-hidden", splitOpen ? "false" : "true");

  setTimeout(() => {
    try { map.invalidateSize(); } catch (e) {}
  }, 280);
  
  // NUEVO: Guardar estado cuando se abre/cierra el panel
  if (splitOpen && currentSideRecintoId) {
    guardarEstadoMapa();
  } else {
    sessionStorage.removeItem('mapaEstado');
  }
}

  window.addEventListener('resize', () => {
    if (splitOpen) {
      setNavbarHeightVar();
      try { map.invalidateSize(); } catch (e) {}
    }
  });

  // Cerrar split
  const sideCloseBtn = document.getElementById("side-close");
  if (sideCloseBtn) {
    sideCloseBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();

      // 1) cerrar cualquier popup abierto
      try { map.closePopup(); } catch (_) {}

      // 2) quitar resaltado rojo
      clearHighlight();

      // 3) cerrar panel
      closeHistoricoPanel();
      closeOperacionesPanel();
      // closeGaleriaPanel?.();   //REVISAR
      setSplitMode(false);

      // reset id actual
      window.currentSideRecintoId = null;
    });
  }

  // ============================
  // EDITAR NOMBRE (lápiz)
  // Enter o blur => guardar
  // Escape => cancelar
  // ============================

  let currentSideRecintoId = null;
  let originalTitleText = "";

  const btnEdit = document.getElementById("btn-edit-name");
  const titleEl = document.getElementById("side-title");


  if (btnEdit && titleEl) {

    btnEdit.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();

      if (!currentSideRecintoId) {
        console.warn("No hay currentSideRecintoId");
        return;
      }

      originalTitleText = titleEl.textContent.trim();
      titleEl.setAttribute("contenteditable", "true");
      titleEl.focus();

      // Seleccionar todo el texto
      const range = document.createRange();
      range.selectNodeContents(titleEl);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    });

    titleEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        titleEl.blur();
      }

      if (e.key === "Escape") {
        e.preventDefault();
        titleEl.textContent = originalTitleText;
        titleEl.removeAttribute("contenteditable");
      }
    });

    titleEl.addEventListener("blur", async () => {
      titleEl.removeAttribute("contenteditable");

      const nuevoNombre = titleEl.textContent.trim();

      if (!nuevoNombre || nuevoNombre === originalTitleText) {
        titleEl.textContent = originalTitleText;
        return;
      }

      try {
        const r = await fetch(
          `/api/mis-recinto/${currentSideRecintoId}/nombre`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ nombre: nuevoNombre })
          }
        );

        if (!r.ok) throw new Error();

      } catch (err) {
        console.error(err);
        titleEl.textContent = originalTitleText;
        mostrarErrorInline("No se pudo guardar el nombre");
      }
    });

  }

  window.safeText = function(v, fallback = "-") {
    if (v === null || v === undefined) return fallback;
    const s = String(v).trim();
    return s === "" ? fallback : s;
  }

  function parseBool(v, def = true) {
    if (v === undefined || v === null) return def;
    if (typeof v === "boolean") return v;
    if (typeof v === "number") return v !== 0;
    const s = String(v).toLowerCase().trim();
    if (["t","true","1","yes","y","si","sí"].includes(s)) return true;
    if (["f","false","0","no","n"].includes(s)) return false;
    return def;
  }

  function formatAreaHa(p) {
    const a = p.superficie_ha ?? p.superficie ?? p.area_ha ?? p.area ?? null;
    if (a === null || a === undefined || a === "") return "-";
    const n = Number(a);
    if (!Number.isFinite(n)) return safeText(a);
    return `${n.toFixed(2).replace(".", ",")} ha`;
  }

  function formatDateValue(v) {
    if (!v) return "-";
    const d = new Date(v);
    if (Number.isNaN(d.getTime())) return safeText(v);

    const dd = String(d.getDate()).padStart(2, "0");
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const yyyy = String(d.getFullYear());
    const hh = String(d.getHours()).padStart(2, "0");
    const min = String(d.getMinutes()).padStart(2, "0");
    return `${dd}/${mm}/${yyyy} ${hh}:${min}`;
  }

  function renderSidePanelFromProps(p) {
    window.currentSideRecintoId = p.id || p.id_recinto;
    document.getElementById("side-title").textContent = safeText(p.nombre, "Recinto");
    document.getElementById("side-area").textContent = (p.superficie_ha == null)
      ? "-"
      : `${Number(p.superficie_ha).toFixed(2).replace(".", ",")} ha`;
    document.getElementById("side-owner").textContent = safeText(p.propietario, "N/A");
    document.getElementById("side-active").checked = (p.activa == null) ? true : !!p.activa;

    // Mostrar coordenadas del centroide
    const coordsText = document.getElementById("side-coords");
    if (p.centroid_lat != null && p.centroid_lng != null) {
      coordsText.textContent = `${p.centroid_lat.toFixed(6)}, ${p.centroid_lng.toFixed(6)}`;
    } else {
      coordsText.textContent = "-";
    }


    window.galeria.setRecintoId(window.currentSideRecintoId);
    window.ndviManager.setRecintoId(window.currentSideRecintoId);
    

    window.renderCultivosForRecinto?.(currentSideRecintoId);
    window.renderOperacionesForRecinto?.(currentSideRecintoId);
  }


const btnDelete = document.getElementById("btn-delete-recinto");
if (btnDelete) {
  btnDelete.addEventListener("click", async (e) => {
    e.preventDefault();
    e.stopPropagation();

    if (!currentSideRecintoId) {
      console.warn("No hay recinto seleccionado");
      return;
    }

    const motivo = (await openMotivoEliminacionModal())?.trim();
    if (!motivo) return;

    btnDelete.disabled = true;

    try {
      const response = await fetch(`/api/solicitud-eliminar-recinto/${currentSideRecintoId}/borrar`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ motivo })
      });

      const data = await response.json().catch(() => ({}));

      if (!response.ok) {
        throw new Error(data.error || "Error al crear la solicitud");
      }

      NotificationSystem.show({
        type: "success",
        title: "Solicitud enviada",
        message: data.mensaje || "La solicitud se creó correctamente"
      });

    } catch (err) {
      console.error("Error al solicitar eliminación:", err);
      NotificationSystem.show({
        type: "error",
        title: "Error",
        message: err.message || "Error al solicitar eliminación"
      });
    } finally {
      btnDelete.disabled = false;
    }
  });
}

// Función auxiliar para mostrar mensajes de éxito
// --------------------------------

  async function guardarNombreRecinto(nombre) {
    if (!currentSideRecintoId) return;

    try {
      const r = await fetch(
        `/api/mis-recinto/${currentSideRecintoId}/nombre`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ nombre })
        }
      );

      if (!r.ok) throw new Error();
    } catch (e) {
      mostrarErrorInline("No se pudo guardar el nombre");
    }
  }

    // CHECKBOX activo
    const sideActive = document.getElementById("side-active");
    if (sideActive) {
      sideActive.addEventListener("change", async () => {
        if (!currentSideRecintoId) return;

        const prev = !sideActive.checked; // estado anterior
        const next = sideActive.checked;

        sideActive.disabled = true;

        try {
          const r = await fetch(`/api/mis-recinto/${currentSideRecintoId}/activa`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ activa: next }),
          });

          const resp = await r.json().catch(() => ({}));
          if (!r.ok || !resp.ok) {
            throw new Error(resp.error || "No se pudo actualizar 'activa'");
          }

          // asegurar checkbox según backend
          sideActive.checked = !!resp.activa;

        } catch (err) {
          console.error(err);
          // revertir si falla
          sideActive.checked = prev;

          NotificationSystem.show({
            type: "error",
            title: "No se pudo guardar",
            message: "No se ha podido actualizar el estado del recinto. Intenta de nuevo."
          });
        } finally {
          sideActive.disabled = false;
        }
      });
    }

  // -----------------------------------------
  // 3) Capas base
  // -----------------------------------------
  const baseOSM = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    {
      attribution: "&copy; OpenStreetMap contributors",
      minZoom: 8,
      maxZoom: 19,
    }
  ).addTo(map);

  const baseSat = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    {
      attribution: "Tiles &copy; Esri",
      minZoom: 8,
      maxZoom: 19,
    }
  );

  const baseSentinelRecent = L.imageOverlay(
    `/static/sentinel2/s2_rgb_latest_3857.png?v={{ s2_version }}`,
    S2_BOUNDS,
    { opacity: 1.0, className: "s2-overlay", interactive: false }
  );

  const baseNdvi = L.imageOverlay(
    `/static/ndvi/ndvi_latest_3857.png?v={{ ndvi_version }}`,
    NDVI_BOUNDS,
    { opacity: 1.0, className: "ndvi-overlay", interactive: false }
  );

  const highZoomLayers = {
    satellite: baseSat,
    sentinel_recent: baseSentinelRecent,
    ndvi: baseNdvi
  };

  const urlParams = new URLSearchParams(window.location.search);
  const capaInicial = urlParams.get('capa') || 'satellite';


  function actualizarBasemapUI(layerKey) {
  document.querySelectorAll('.basemap-option.basemap-main')
    .forEach(opt => opt.classList.remove('active'));

  const activeOption = document.querySelector(
    `.basemap-option.basemap-main[data-layer="${layerKey}"]`
  );

  if (activeOption && !activeOption.classList.contains('disabled')) {
    activeOption.classList.add('active');
  }
}

  let activeHighLayerKey = capaInicial;
  actualizarBasemapUI(activeHighLayerKey);
  function getActiveHighLayer() {
    return highZoomLayers[activeHighLayerKey];
  }

  // -----------------------------------------
  // 4) Capa de recintos
  // -----------------------------------------

  const RECINTO_STYLE_DEFAULT = {
    color: "#ff8800",
    weight: 1,
  };

  const RECINTO_STYLE_SELECTED = {
    color: "#0077ff",
    weight: 2,
    fillOpacity: 0.25,
  };

  let selectedRecintoLayer = null;
  

  const recintosLayer = L.geoJSON(null, {
    pane: 'sigpacPane',
    style: function () {
      return RECINTO_STYLE_DEFAULT;
    },
    onEachFeature: function (feature, layer) {
      const p = feature.properties || {};

      // Propietario: username o "N/A"
      const propietarioTexto =
        p.propietario && String(p.propietario).trim() !== ""
          ? p.propietario
          : "N/A";

      const tienePropietario = propietarioTexto !== "N/A";
      const disabledAttr = tienePropietario ? "disabled" : "";
      const disabledStyle = tienePropietario
        ? "opacity: 0.5; cursor: not-allowed;"
        : "";

      const html = `
        <div class="popup-recinto">
          <div class="popup-recinto-info">
            <strong>Provincia:</strong> ${p.provincia ?? " "} - ${p.nombre_provincia ?? " "}<br>
            <strong>Municipio:</strong> ${p.municipio ?? " "} - ${p.nombre_municipio ?? " "}<br>
            <strong>Polígono:</strong> ${p.poligono ?? "-"}<br>
            <strong>Parcela:</strong> ${p.parcela ?? "-"}<br>
            <strong>Recinto:</strong> ${p.recinto ?? "-"}<br>
            <strong>Propietario:</strong> ${propietarioTexto}
          </div>
          <div style="margin-top: 10px; text-align: right;">
            <button
              type="button"
              class="btn-add-recinto"
              data-id-recinto="${p.id_recinto ?? ""}"
              data-provincia="${p.provincia ?? ""}"
              data-municipio="${p.municipio ?? ""}"
              data-agregado="${p.agregado ?? ""}"
              data-zona="${p.zona ?? ""}"
              data-poligono="${p.poligono ?? ""}"
              data-parcela="${p.parcela ?? ""}"
              data-recinto="${p.recinto ?? ""}"
              ${disabledAttr}
              style="
                padding: 6px 10px;
                font-size: 0.85rem;
                border-radius: 999px;
                border: none;
                background-color: #198754;
                color: white;
                cursor: pointer;
                ${disabledStyle}
              "
              onclick="window._solicitarRecintoDesdePopup(this)"
            >
              Añadir a mis recintos
            </button>
          </div>
        </div>
      `;

      layer.bindPopup(html);

      // Marcar visualmente la selección
      layer.on("click", function () {
        if (selectedRecintoLayer && selectedRecintoLayer !== layer) {
          selectedRecintoLayer.setStyle(RECINTO_STYLE_DEFAULT);
        }
        selectedRecintoLayer = layer;
        layer.setStyle(RECINTO_STYLE_SELECTED);
        layer.openPopup();
      });
    },
  }).addTo(map);

  // ============================
  // Highlight para WMS (Cultivos/Catastro)
  // ============================
  map.createPane("wmsHighlightPane");
  map.getPane("wmsHighlightPane").style.zIndex = 650; // por encima de WMS

  const CULTIVO_HL_STYLE = { color: "#0077ff", weight: 2, fillColor: "#0077ff", fillOpacity: 0.20 };
  const CATASTRO_HL_STYLE = { color: "#0077ff", weight: 2, fillColor: "#0077ff", fillOpacity: 0.20 };

  let cultivoHighlightLayer = null;
  let catastroHighlightLayer = null;

  function clearCultivoHighlight() {
    if (cultivoHighlightLayer) {
      try { map.removeLayer(cultivoHighlightLayer); } catch (_) {}
      cultivoHighlightLayer = null;
    }
  }

  function clearCatastroHighlight() {
    if (catastroHighlightLayer) {
      try { map.removeLayer(catastroHighlightLayer); } catch (_) {}
      catastroHighlightLayer = null;
    }
  }

  function highlightGeojson(geojson, which) {
    // Limpiar highlights previos
    clearCultivoHighlight();
    clearCatastroHighlight();

    if (!geojson) return;

    // limpiar el otro highlight para evitar “doble selección”
    if (which === "cultivo") clearCatastroHighlight();
    if (which === "catastro") clearCultivoHighlight();

    const layer = L.geoJSON(geojson, {
      pane: "wmsHighlightPane",
      style: which === "cultivo" ? CULTIVO_HL_STYLE : CATASTRO_HL_STYLE
    }).addTo(map);

    layer.bringToFront();

    if (which === "cultivo") cultivoHighlightLayer = layer;
    else catastroHighlightLayer = layer;
  }

  map.on("popupclose", () => {
    clearCultivoHighlight();
    clearCatastroHighlight();
  });

  function openSigpacPopupForKey(key) {
    let targetLayer = null;

    recintosLayer.eachLayer((lyr) => {
      const p = (lyr.feature && lyr.feature.properties) || {};
      if (String(p.id_recinto) === String(key)) targetLayer = lyr;
    });

    if (!targetLayer) return false;

    if (selectedRecintoLayer && selectedRecintoLayer !== targetLayer) {
      selectedRecintoLayer.setStyle(RECINTO_STYLE_DEFAULT);
    }
    selectedRecintoLayer = targetLayer;
    targetLayer.setStyle(RECINTO_STYLE_SELECTED);
    targetLayer.openPopup();
    return true;
  }

  function openSigpacPopupForKeyWithRetry(key, tries = 12) {
    if (openSigpacPopupForKey(key)) return;
    if (tries <= 0) return;
    setTimeout(() => openSigpacPopupForKeyWithRetry(key, tries - 1), 250);
  }

  const MIS_RECINTO_STYLE = {
    color: "#00a86b",
    weight: 5,
    opacity: 1,
    fillColor: "#00a86b",
    fillOpacity: 0.22,
  };

function actualizarNdviPanel() {
  if (window.ndviManager && window.ndviManager.panelDetalleAbierto) {
    // El panel está abierto, se actualizará automáticamente cuando
    // se llame a setRecintoId en renderSidePanelFromProps
    return true; // Indica que el panel estaba abierto
  }
  return false;
}


async function abrirRecintoEnPanel(data) {
  if (!data || !data.id) return;

  // Detectar qué paneles están abiertos ANTES de cambiar los datos
  const ndviAbierto = actualizarNdviPanel();
  const cultivosAbierto = document.getElementById("side-panel")?.classList.contains("cultivos-historico-open");
  const operacionesAbierto = document.getElementById("side-panel")?.classList.contains("operaciones-open");
  const galeriaAbierta = document.getElementById("side-panel")?.classList.contains("galeria-open");

  // abrir split
  setSplitMode(true);

  // setear id global
  currentSideRecintoId = data.id;

  // pintar panel (esto actualizará automáticamente el contenido base y NDVI)
  renderSidePanelFromProps(data);

  // Actualizar los paneles que estaban abiertos
  setTimeout(() => {
    if (cultivosAbierto) {
      actualizarHistoricoCultivos();
    }
    if (operacionesAbierto) {
      actualizarHistoricoOperaciones();
    }
    if (galeriaAbierta) {
      actualizarGaleria();
    }
    // El NDVI se actualiza automáticamente en renderSidePanelFromProps
  }, 100);

  // centrar y resaltar
  centrarEnRecinto(data);
  
  // Guardar estado después de abrir
  setTimeout(() => guardarEstadoMapa(), 300);
}

  async function abrirRecintoDesdeVer(dataFlask) {
    if (!dataFlask || !dataFlask.id) return;

    // Siempre centramos y resaltamos en rojo
    centrarEnRecinto(dataFlask);

    // Comprobar si es mío intentando pedir detalle "mis-recinto"
    try {
      const r = await fetch(`/api/mis-recinto/${dataFlask.id}`);
      if (!r.ok) throw new Error("No es mío");

      const dataDb = await r.json();

      // Es mío -> abrir panel con datos reales de BBDD
      setSplitMode(true);
      currentSideRecintoId = dataDb.id;
      renderSidePanelFromProps(dataDb);

    } catch (_) {
      // No es mío (admin u otro) -> NO abrir panel
      setSplitMode(false);
    }
  }

  async function abrirSidePanelSiEsMio(recintoId) {
    if (!recintoId) return false;

    try {
      const r = await fetch(`/api/mis-recinto/${recintoId}`);
      if (!r.ok) return false;

      const dataDb = await r.json();

      setSplitMode(true);
      currentSideRecintoId = dataDb.id;
      renderSidePanelFromProps(dataDb);

      return true;
    } catch (e) {
      return false;
    }
  }

  async function centrarYAbrirPanelSiEsMio(dataFlask) {
    if (!dataFlask || !dataFlask.id) return;
    centrarEnRecinto(dataFlask);
    await abrirSidePanelSiEsMio(dataFlask.id);
  }

  const misRecintosLayer = L.geoJSON(null, {
    pane: 'misPane',
    style: () => MIS_RECINTO_STYLE,
    onEachFeature: function (feature, layer) {
      layer.on("click", async function (e) {
        try { L.DomEvent.stop(e); } catch (_) {}

        const id = feature?.properties?.id_recinto;
        if (!id) return;

        try {
          const r = await fetch(`/api/mis-recinto/${id}`);
          if (!r.ok) throw new Error("No se pudo cargar detalle del recinto");
          const data = await r.json();

          abrirRecintoEnPanel(data);

        } catch (err) {
          console.error(err);
        }
      });
    }
  }).addTo(map);
    
  // Mis IDs para evitar duplicados
  const MIS_IDS = new Set();

  // Por defecto activos
  let misRecintosActivos = true;

 function cargarMisRecintosSiProcede() {
  const z = map.getZoom();

  // Siempre limpiar primero
  if (z < ZOOM_RECINTOS || !misRecintosActivos) {
    misRecintosLayer.clearLayers();
    return;
  }

  const b = map.getBounds();
  const bbox = [
    b.getWest().toFixed(6),
    b.getSouth().toFixed(6),
    b.getEast().toFixed(6),
    b.getNorth().toFixed(6),
  ].join(",");

  fetch(`/api/mis-recintos?bbox=${bbox}`)
    .then((r) => {
      if (!r.ok) throw new Error("Respuesta no OK de /api/mis-recintos");
      return r.json();
    })
    .then((fc) => {
      // Verificar de nuevo el zoom antes de añadir
      if (map.getZoom() < ZOOM_RECINTOS) {
        misRecintosLayer.clearLayers();
        return;
      }
      
      misRecintosLayer.clearLayers();

      MIS_IDS.clear();
      if (fc && fc.features && fc.features.length) {
        fc.features.forEach(f => {
          const p = f.properties || {};
          if (p.id_recinto != null) MIS_IDS.add(String(p.id_recinto));
        });
        misRecintosLayer.addData(fc);
      }
    })
    .catch((err) => console.error("Error al cargar mis recintos:", err));
}

  // *** Recintos activos por defecto ***
  let recintosActivos = true;
  let recintosRequestToken = 0;

  // Función auxiliar para llamar a la API de solicitudes
  function solicitarRecinto(payload) {
    fetch("/api/solicitudes-recinto", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    })
      .then((response) => response.json().catch(() => ({})))
      .then((data) => {
        if (data && data.ok) {
         NotificationSystem.show({
            type: 'success',
            title: '¡Solicitud enviada!',
            message: 'Tu solicitud ha sido enviada al administrador correctamente.'
          }); 
        } else {
          const msg = (data && data.error) || "No se ha podido crear la solicitud. ¿Estás identificado?";
          console.error("Error en la respuesta de la API:", data);

          NotificationSystem.show({
            type: 'error',
            title: 'Error en la solicitud',
            message: msg
          });
        }
      })
      .catch((err) => {
        console.error("Error al crear la solicitud de recinto:", err);

        NotificationSystem.show({
          type: 'warning',
          title: 'Error de comunicación',
          message: 'No se pudo conectar con el servidor. Por favor, intenta de nuevo.'
        });
      });
  }

  // -----------------------------------------
  // Parcelas Catastro + Cultivos SIGPAC (WMS desde GeoServer)
  // -----------------------------------------

  // 1) URL WMS
  const GEOSERVER_WMS = "http://100.102.237.86:8080/geoserver/wms";

  // 2) Flags de visibilidad
  let parcelasCatastroActivas = false;
  let cultivosSigpacActivos = false;

  // 3) Capas WMS
  const parcelasCatastroLayer = L.tileLayer.wms(GEOSERVER_WMS, {
    layers: "gis_project:parcelasCatastro",
    styles: "catastro_fucsia", 
    format: "image/png",
    transparent: true,
    tiled: true,
    pane: "catastroPane",
    maxZoom: 22
  });

  const cultivosSigpacLayer = L.tileLayer.wms(GEOSERVER_WMS, {
    layers: "gis_project:cultivo_declarado", 
    styles: "cultivos_verde", 
    format: "image/png",
    transparent: true,
    tiled: true,
    pane: "cultivosSigpacPane",
    maxZoom: 22
  });

  // 4) Sólo mostrar a partir de cierto zoom
  function cargarParcelasCatastroSiProcede() {
    const z = map.getZoom();
    if (!parcelasCatastroActivas || z < ZOOM_RECINTOS) {
      if (map.hasLayer(parcelasCatastroLayer)) map.removeLayer(parcelasCatastroLayer);
      return;
    }
    if (!map.hasLayer(parcelasCatastroLayer)) parcelasCatastroLayer.addTo(map);
  }

  function cargarCultivosSigpacSiProcede() {
    const z = map.getZoom();
    if (!cultivosSigpacActivos || z < ZOOM_RECINTOS) {
      if (map.hasLayer(cultivosSigpacLayer)) map.removeLayer(cultivosSigpacLayer);
      return;
    }
    if (!map.hasLayer(cultivosSigpacLayer)) cultivosSigpacLayer.addTo(map);
  }

  // Funciones auxiliares para popups
  function fmt(v, fallback = "-") {
    if (v === null || v === undefined) return fallback;
    const s = String(v).trim();
    return s === "" ? fallback : s;
  }

  function abrirPopupHtml(latlng, html) {
    L.popup({ maxWidth: 320, autoPan: true })
      .setLatLng(latlng)
      .setContent(html)
      .openOn(map);
  }

  function buildCultivoPopup(d) {
    const cultivoNombre = fmt(d.parc_producto_nombre || d.cultivo_actual_nombre, "Cultivo");

    const provinciaTxt = `${fmt(d.provincia)}${d.nombre_provincia ? " - " + d.nombre_provincia : ""}`;
    const municipioTxt = `${fmt(d.municipio)}${d.nombre_municipio ? " - " + d.nombre_municipio : ""}`;

    const prodNombre = fmt(d.parc_producto_nombre, "");
    const prodTxt = prodNombre ? `${fmt(d.parc_producto)} - ${prodNombre}` : fmt(d.parc_producto);

    return `
      <div class="popup-recinto" style="min-width: 250px;">
        <div class="popup-recinto-info" style="font-size: 0.9rem;">
          <div style="font-weight: 800; margin-bottom: 6px;">${cultivoNombre}</div>
          <strong>Provincia:</strong> ${provinciaTxt}<br>
          <strong>Municipio:</strong> ${municipioTxt}<br>
          <strong>Parcela:</strong> ${fmt(d.parcela)}<br>
          <strong>Recinto:</strong> ${fmt(d.recinto)}<br>
          <hr style="margin: 8px 0;">
          <strong>Producto:</strong> <strong>${prodTxt}</strong><br>
          <strong>Sist. exp.:</strong> ${fmt(d.parc_sistexp)}<br>
        </div>
      </div>
    `;
  }

  function buildCatastroPopup(d) {
    const areaHa = d.area_m2 ? (Number(d.area_m2) / 10000).toFixed(2) : null;

    return `
      <div class="popup-recinto" style="min-width: 250px;">
        <div class="popup-recinto-info" style="font-size: 0.9rem;">
          <div style="font-weight: 800; margin-bottom: 6px;">Parcela Catastro</div>
          <strong>Ref. Catastral:</strong> ${fmt(d.refcat)}<br>
          <strong>Área:</strong> ${areaHa ? areaHa + " ha" : "-"}<br>
        </div>
      </div>
    `;
  }

  // 5) Handler click mapa para popups
  map.on("click", async (e) => {
    // Evitar que un click sobre una geometría interactiva (recintos/mis recintos) dispare también esto
    const t = e?.originalEvent?.target;
    if (t && (t.classList?.contains("leaflet-interactive") || t.closest?.(".leaflet-interactive"))) return;
    if (map.getZoom() < ZOOM_RECINTOS) return;

    try {
      // prioridad: si están ambos activos por error, mostramos el que esté activo (cultivos > catastro)
      if (cultivosSigpacActivos) {
        const r = await fetch(`/api/popup/cultivo-sigpac?lat=${e.latlng.lat}&lng=${e.latlng.lng}`);
        const j = await r.json().catch(() => ({}));
        if (j.ok && j.found) {
          highlightGeojson(j.data.geojson, "cultivo"); 
          abrirPopupHtml(e.latlng, buildCultivoPopup(j.data));
          return;
        }
      }

      if (parcelasCatastroActivas) {
        const r = await fetch(`/api/popup/catastro?lat=${e.latlng.lat}&lng=${e.latlng.lng}`);
        const j = await r.json().catch(() => ({}));
        if (j.ok && j.found) {
          highlightGeojson(j.data.geojson, "catastro");
          abrirPopupHtml(e.latlng, buildCatastroPopup(j.data));
          return;
        }
      }

      // si no hay nada debajo, cerramos popup y highlights
      map.closePopup();
      clearCultivoHighlight();
      clearCatastroHighlight();
    } catch (err) {
      console.error("Error popup click:", err);
    }
  });

  // -----------------------------------------

  // Función auxiliar para mensajes tipo bootstrap
  function mostrarErrorInline(msg) {
    const c = document.getElementById("side-alerts");
    if (!c) return;

    c.innerHTML = `
      <div class="alert alert-danger alert-dismissible fade show" role="alert">
        ${msg}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      </div>
    `;
  }

  // Handler global llamado desde el botón del popup
  window._solicitarRecintoDesdePopup = function (btn) {
    if (!btn || btn.disabled) return;

    const ds = btn.dataset;

    const payload = {
      id_recinto: ds.idrecinto || null,
      provincia: ds.provincia ? Number(ds.provincia) : null,
      municipio: ds.municipio ? Number(ds.municipio) : null,
      nombre_municipio: ds.nombre_municipio ? ds.nombre_municipio : null,
      nombre_provincia: ds.nombre_provincia ? ds.nombre_provincia : null,
      agregado: ds.agregado ? Number(ds.agregado) : null,
      zona: ds.zona ? Number(ds.zona) : null,
      poligono: ds.poligono ? Number(ds.poligono) : null,
      parcela: ds.parcela ? Number(ds.parcela) : null,
      recinto: ds.recinto ? Number(ds.recinto) : null,
    };

    solicitarRecinto(payload);
  };

  // -----------------------------------------
  // 5) Cargar recintos
  // -----------------------------------------
  function cargarRecintosSiProcede() {
    const z = map.getZoom();

    // Siempre limpiar primero si no procede
    if (z < ZOOM_RECINTOS || !recintosActivos) {
      recintosLayer.clearLayers();
      return;
    }

    // Token de esta petición
    const myToken = ++recintosRequestToken;

    const b = map.getBounds();
    const bbox = [
      b.getWest().toFixed(6),
      b.getSouth().toFixed(6),
      b.getEast().toFixed(6),
      b.getNorth().toFixed(6),
    ].join(",");

    console.log("Solicitando recintos para bbox:", bbox);

    fetch(`/api/recintos?bbox=${bbox}`)
      .then((response) => {
        if (!response.ok) throw new Error("Respuesta no OK de /api/recintos");
        return response.json();
      })
      .then((fc) => {
        // Si llegó tarde (hay otra petición más nueva), ignorar
        if (myToken !== recintosRequestToken) return;

        // Si se desactivó mientras esperábamos, ignorar y limpiar
        if (!recintosActivos) {
          recintosLayer.clearLayers();
          return;
        }

        // Si el zoom bajó mientras esperábamos, limpiar y salir
        if (map.getZoom() < ZOOM_RECINTOS) {
          recintosLayer.clearLayers();
          return;
        }

        console.log("Recintos recibidos:", fc && fc.features ? fc.features.length : 0);

        // Guardar información del popup abierto antes de limpiar
        let popupAbiertoId = null;
        let popupEstiloSeleccionado = false;

        recintosLayer.eachLayer((layer) => {
          if (layer.isPopupOpen && layer.isPopupOpen()) {
            const props = layer.feature?.properties || {};
            popupAbiertoId = props.id_recinto;
            popupEstiloSeleccionado = (selectedRecintoLayer === layer);
            console.log("Popup abierto detectado para recinto:", popupAbiertoId);
          }
        });

        recintosLayer.clearLayers();

        if (!fc || !fc.features || fc.features.length === 0) return;

        // Recheck final antes de pintar (por si cambió justo ahora)
        if (myToken !== recintosRequestToken || !recintosActivos || map.getZoom() < ZOOM_RECINTOS) return;

        recintosLayer.addData(fc);

        // Reabrir el popup si estaba abierto
        if (popupAbiertoId) {
          recintosLayer.eachLayer((layer) => {
            const props = layer.feature?.properties || {};
            if (String(props.id_recinto) === String(popupAbiertoId)) {
              console.log("Reabriendo popup para recinto:", popupAbiertoId);

              // Restaurar estilo de selección si lo tenía
              if (popupEstiloSeleccionado) {
                selectedRecintoLayer = layer;
                try { layer.setStyle(RECINTO_STYLE_SELECTED); } catch (_) {}
              }

              // Reabrir popup con pequeño delay
              setTimeout(() => {
                // Si ya no procede cuando vaya a abrir, no lo abras
                if (myToken !== recintosRequestToken || !recintosActivos) return;
                try { layer.openPopup(); } catch (_) {}
              }, 50);
            }
          });
        }
      })
      .catch((err) => {
        // Si el error viene de que se invalidó/cambió de capa, no es grave
        console.error("Error al cargar recintos:", err);
      });
  }

  // -----------------------------------------
  // 6) Actualizar mapa según zoom
  // -----------------------------------------
  function actualizarMapaSegunZoom() {
    const z = map.getZoom();
    const activeHighLayer = getActiveHighLayer();

    if (z >= ZOOM_RECINTOS) {
      if (map.hasLayer(baseOSM)) {
        map.removeLayer(baseOSM);
      }

      Object.values(highZoomLayers).forEach((layer) => {
        if (layer && layer !== activeHighLayer && map.hasLayer(layer)) {
          map.removeLayer(layer);
        }
      });

      if (activeHighLayer && !map.hasLayer(activeHighLayer)) {
        activeHighLayer.addTo(map);
      }
    } else {
      Object.values(highZoomLayers).forEach((layer) => {
        if (layer && map.hasLayer(layer)) {
          map.removeLayer(layer);
        }
      });

      if (!map.hasLayer(baseOSM)) {
        baseOSM.addTo(map);
      }

      recintosLayer.clearLayers();
    }
  }

  // -----------------------------------------
  // 7) Eventos del mapa
  // -----------------------------------------

  map.on("zoomend", () => {
    actualizarMapaSegunZoom();
    cargarRecintosSiProcede();
    cargarMisRecintosSiProcede();
    cargarParcelasCatastroSiProcede();
    cargarCultivosSigpacSiProcede();
    if (splitOpen && currentSideRecintoId) {
    guardarEstadoMapa();
  }
  });

  map.on("moveend", () => {
    cargarRecintosSiProcede();
    cargarMisRecintosSiProcede();
    cargarParcelasCatastroSiProcede();
    cargarCultivosSigpacSiProcede();
  });

  actualizarMapaSegunZoom();
  cargarRecintosSiProcede();
  cargarMisRecintosSiProcede();
  cargarParcelasCatastroSiProcede();
  cargarCultivosSigpacSiProcede();

  // -----------------------------------------
  // 8) Lógica del panel y botones sincronizados
  // -----------------------------------------
  const toggleBtn = document.getElementById("basemap-toggle");
  const panel = document.getElementById("basemap-panel");
  const basemapContainer = document.getElementById("basemap-panel-container");
  const filtroContainer = document.getElementById("filtro-container");

  toggleBtn.addEventListener("click", () => {
    const isOpening = !panel.classList.contains("visible");

    panel.classList.toggle("visible");
    toggleBtn.classList.toggle("active");

    // Desplazar ambos contenedores
    if (isOpening) {
      basemapContainer.classList.add("panel-open");
      filtroContainer.classList.add("panel-open");
    } else {
      basemapContainer.classList.remove("panel-open");
      filtroContainer.classList.remove("panel-open");
    }
  });

  // --- Selección de mapa principal ---
  document
    .querySelectorAll(".basemap-option.basemap-main[data-layer]")
    .forEach((option) => {
      if (option.classList.contains("disabled")) return;
      option.addEventListener("click", () => {
        const layerKey = option.dataset.layer;
        if (!highZoomLayers[layerKey]) {
          return;
        }

        document
          .querySelectorAll(".basemap-option.basemap-main")
          .forEach((el) => el.classList.remove("active"));
        option.classList.add("active");

        activeHighLayerKey = layerKey;
        actualizarMapaSegunZoom();
      });
    });

  // --- Toggle MisRecintos ---
  const misRecintosOption = document.querySelector(
    '.basemap-option.basemap-detail[data-detail="mis"]'
  );

  if (misRecintosOption) {
    misRecintosOption.addEventListener("click", () => {
      misRecintosActivos = !misRecintosActivos;

      if (misRecintosActivos) {
        misRecintosOption.classList.add("active");
        cargarMisRecintosSiProcede();
      } else {
        misRecintosOption.classList.remove("active");
        misRecintosLayer.clearLayers();
      }
    });
  }

  // --- Toggle Recintos SigPac ---
  const recintosOption = document.querySelector(
    '.basemap-option.basemap-detail[data-detail="sigpac"]'
  );

  if (recintosOption) {
    recintosOption.addEventListener("click", () => {
      if (recintosActivos) {
        desactivarDetalle("sigpac");
      } else {
        activarDetalleExclusivo("sigpac");
      }
    });
  }

  // --- Toggle Cultivos SIGPAC ---
  const cultivosSigpacOption = document.querySelector(
    '.basemap-option.basemap-detail[data-detail="cultivosSigpac"]'
  );

  if (cultivosSigpacOption) {
    cultivosSigpacOption.addEventListener("click", () => {
      if (cultivosSigpacActivos) {
        desactivarDetalle("cultivosSigpac");
      } else {
        activarDetalleExclusivo("cultivosSigpac");
      }
    });
  }

  // --- Toggle Parcelas Catastro ---
  const parcelasCatastroOption = document.querySelector(
    '.basemap-option.basemap-detail[data-detail="catastro"]'
  );

  if (parcelasCatastroOption) {
    parcelasCatastroOption.addEventListener("click", () => {
      if (parcelasCatastroActivas) {
        desactivarDetalle("catastro");
      } else {
        activarDetalleExclusivo("catastro");
      }
    });
  }

  // Funciones para activar/desactivar detalles de los toggles
  function desactivarDetalle(key) {
    const opt = document.querySelector(`.basemap-option.basemap-detail[data-detail="${key}"]`);
    if (opt) opt.classList.remove("active");

    // cerrar popups y limpiar resaltados al cambiar de capa
    try { map.closePopup(); } catch (_) {}

    // limpiar highlights WMS
    clearCultivoHighlight();
    clearCatastroHighlight();

    if (key === "sigpac") {
      recintosActivos = false;
      recintosRequestToken++;
      recintosLayer.clearLayers();
    } else if (key === "cultivosSigpac") {
      cultivosSigpacActivos = false;
      if (map.hasLayer(cultivosSigpacLayer)) map.removeLayer(cultivosSigpacLayer);
    } else if (key === "catastro") {
      parcelasCatastroActivas = false;
      if (map.hasLayer(parcelasCatastroLayer)) map.removeLayer(parcelasCatastroLayer);
    }
  }

  function activarDetalleExclusivo(key) {
    // apaga los otros (menos "mis")
    ["sigpac", "cultivosSigpac", "catastro"].forEach(k => {
      if (k !== key) desactivarDetalle(k);
    });

    const opt = document.querySelector(`.basemap-option.basemap-detail[data-detail="${key}"]`);
    if (opt) opt.classList.add("active");

    if (key === "sigpac") {
      recintosActivos = true;
      cargarRecintosSiProcede();
    } else if (key === "cultivosSigpac") {
      cultivosSigpacActivos = true;
      cargarCultivosSigpacSiProcede();
    } else if (key === "catastro") {
      parcelasCatastroActivas = true;
      cargarParcelasCatastroSiProcede();
    }
  }

  // ============================================
  // CENTRAR EN RECINTO ESPECÍFICO
  // ============================================

  // Recibir datos del recinto específico desde Flask
  const recintoData = {{ recinto_data| tojson | safe if recinto_data else 'null' }};

  // Variable para guardar la capa del recinto resaltado
  let recintoResaltado = null;

  // Función para limpieza de capa roja
  function clearHighlight() {
    if (recintoResaltado) {
      try {
        map.removeLayer(recintoResaltado); // Quita la capa roja
      } catch (e) { }
      recintoResaltado = null;
    }
  }

  // Función para centrar en un recinto específico
  function centrarEnRecinto(data) {
    if (!data) return;

    // Limpiar cualquier resaltado previo
    clearHighlight();

    console.log('Centrando en recinto:', data);

    try {
      // Parsear el GeoJSON del recinto
      const geojson = JSON.parse(data.geojson);

      // Crear el FeatureCollection completo
      const featureCollection = {
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          geometry: geojson,
          properties: {
            id_recinto: data.id,
            provincia: data.provincia,
            municipio: data.municipio,
            nombre_municipio: data.nombre_municipio,
            nombre_provincia: data.nombre_provincia,
            poligono: data.poligono,
            parcela: data.parcela,
            recinto: data.recinto,
            nombre: data.nombre,
            superficie_ha: data.superficie_ha,
            propietario: data.propietario
          }
        }]
      };

      // Función para abrir popup del recinto en la capa de recintos
      function openSigpacPopupForKey(key) {
        let targetLayer = null;

        recintosLayer.eachLayer((lyr) => {
          const p = (lyr.feature && lyr.feature.properties) || {};
          if (String(p.id_recinto) === String(key)) {
            targetLayer = lyr;
          }
        });

        if (targetLayer) {
          const p = (targetLayer.feature && targetLayer.feature.properties) || {};
          const esMio = MIS_IDS.has(String(key));

          // Si es mío: NO abrir popup ni aplicar estilo azul
          if (esMio) {
            if (selectedRecintoLayer) {
              selectedRecintoLayer.setStyle(RECINTO_STYLE_DEFAULT);
              selectedRecintoLayer = null;
            }
            return; // no abrir popup si es mío
          }

          // Si NO es mío: comportamiento normal (abrir popup "Añadir a mis recintos")
          if (selectedRecintoLayer && selectedRecintoLayer !== targetLayer) {
            selectedRecintoLayer.setStyle(RECINTO_STYLE_DEFAULT);
          }
          selectedRecintoLayer = targetLayer;
          targetLayer.setStyle(RECINTO_STYLE_SELECTED);
          targetLayer.openPopup();
        }
      }

      // Guardar la clave del recinto rojo
      const highlightKey = String(data.id);

      // Crear la geometría con Leaflet con estilo destacado
      recintoResaltado = L.geoJSON(featureCollection, {
        pane: 'highlightPane',
        style: {
          color: '#FF0000',
          weight: 4,
          fillColor: '#FF6B6B',
          fillOpacity: 0.3,
          dashArray: '10, 5'
        }
      }).addTo(map);
      // asegurar arriba del todo
      recintoResaltado.bringToFront();


      // Crear contenido del popup
      const popupContent = `
      <div class="popup-recinto" style="min-width: 250px;">
        <div class="popup-recinto-info" style="font-size: 0.9rem;">
          <strong>Provincia:</strong> ${data.provincia} - ${data.nombre_provincia}<br>
          <strong>Municipio:</strong> ${data.municipio} - ${data.nombre_municipio}<br>
          <strong>Polígono:</strong> ${data.poligono}<br>
          <strong>Parcela:</strong> ${data.parcela}<br>
          <strong>Recinto:</strong> ${data.recinto}<br>
          <strong>Superficie:</strong> ${data.superficie_ha.toFixed(2)} ha<br>
          <strong>Propietario:</strong> ${data.propietario}
        </div>
      </div>
    `;

      // Añadir popup
      recintoResaltado.bindPopup(popupContent, {
        maxWidth: 300,
        className: 'recinto-destacado-popup'
      });

      // Cerrar popup al hacer clic en el recinto rojo
      recintoResaltado.eachLayer((lyr) => {
        lyr.on('click', () => {
          try { lyr.closePopup(); } catch (e) { }
        });
      });


      // Obtener bounds del recinto
      const bounds = recintoResaltado.getBounds();

      // Calcular el zoom apropiado
      const zoom = map.getBoundsZoom(bounds, false);
      const targetZoom = Math.min(zoom, 18); // Máximo zoom 18

      // Primero hacer zoom para que se cargue la capa correcta
      map.setView(bounds.getCenter(), Math.max(targetZoom, ZOOM_RECINTOS));

      // Después de un momento, ajustar el bounds con padding
      setTimeout(() => {
        map.fitBounds(bounds, {
          padding: [80, 80],
          maxZoom: 18,
          animate: true,
          duration: 0.5
        });

        // Abrir el popup después del zoom
        setTimeout(() => {
          recintoResaltado.openPopup();
        }, 600);
      }, 300);

    } catch (error) {
      console.error('Error al centrar en el recinto:', error);

      // Fallback: usar el bbox si falla el GeoJSON
      if (data.bbox && data.bbox.length === 4) {
        const [minx, miny, maxx, maxy] = data.bbox;
        const bounds = [[miny, minx], [maxy, maxx]];

        map.setView(
          [(miny + maxy) / 2, (minx + maxx) / 2],
          Math.max(ZOOM_RECINTOS, 16)
        );

        setTimeout(() => {
          map.fitBounds(bounds, {
            padding: [80, 80],
            maxZoom: 18
          });
        }, 300);
      }
    }
  }

  // Si hay datos de recinto, centrar en él cuando el mapa esté listo
  if (recintoData) {
    console.log('Recinto específico detectado, preparando centrado...');

    // Esperar a que el mapa esté completamente cargado
    map.whenReady(function () {
      console.log('Mapa listo, centrando en recinto...');

      // Activar recintos si están desactivados
      if (!recintosActivos) {
        recintosActivos = true;
        const recintosOption = document.querySelector(
          '.basemap-option.basemap-detail[data-detail="sigpac"]'
        );
        if (recintosOption) {
          recintosOption.classList.add('active');
        }
      }

      // Pequeño delay para asegurar que todo esté inicializado
      setTimeout(() => {
        abrirRecintoDesdeVer(recintoData);
      }, 300);
    });
  }


if (recintoData) {
  const RecentrarControl = L.Control.extend({
    options: {
      position: 'bottomleft'
    },

    onAdd: function (map) {
      const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');

      // 👉 márgenes aquí
      container.style.marginBottom = '100px';
      container.style.marginLeft = '20px';

      const button = L.DomUtil.create('a', '', container);

      button.href = '#';
      button.title = 'Volver a centrar en el recinto';
      button.innerHTML = '<i class="bi bi-crosshair" style="font-size: 18px; line-height: 30px;"></i>';
      button.style.width = '30px';
      button.style.height = '30px';
      button.style.display = 'flex';
      button.style.alignItems = 'center';
      button.style.justifyContent = 'center';
      button.style.backgroundColor = 'white';
      button.style.textDecoration = 'none';
      button.style.color = '#333';

      L.DomEvent.on(button, 'click', function (e) {
        L.DomEvent.stopPropagation(e);
        L.DomEvent.preventDefault(e);
        centrarYAbrirPanelSiEsMio(recintoData);
      });

      return container;
    }
  });

  map.addControl(new RecentrarControl());
}


  const editarBtn = document.getElementById('editar-btn');
  const dibujarBtn = document.getElementById('dibujar-btn');
  const poligonoBtn = document.getElementById('poligono-btn');
  const aceptarBtn = document.getElementById('aceptar-btn');
  const cancelarBtn = document.getElementById('cancelar-btn');
  const limpiarBtn = document.getElementById('limpiar-btn');

  // FeatureGroup para guardar los elementos dibujados
  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

 let rectangleDrawer = null;
  let polygonDrawer = null;
  let dibujosTemporales = [];
  let modoEdicion = false;

  // Función para deshabilitar/habilitar interacción con recintos
  function toggleInteraccionRecintos(enabled) {
    if (enabled) {
      // Reactivar popups
      recintosLayer.eachLayer(layer => {
        if (layer._popup) layer.bindPopup(layer._popup);
      });
    } else {
      // Desactivar popups
      recintosLayer.eachLayer(layer => layer.unbindPopup());
    }
  }

  // Al hacer clic en editar
  editarBtn.addEventListener('click', () => {
    editarBtn.classList.add('hidden');
    dibujarBtn.classList.remove('hidden');
    poligonoBtn.classList.remove('hidden');
    aceptarBtn.classList.remove('hidden');
    cancelarBtn.classList.remove('hidden');
    limpiarBtn.classList.remove('hidden');

    // Activar modo edición y deshabilitar interacción con recintos
    modoEdicion = true;
    toggleInteraccionRecintos(false);

    // Guardar estado actual
    dibujosTemporales = [];
    drawnItems.eachLayer(layer => {
      dibujosTemporales.push(layer);
    });

    console.log('Modo edición activado');
  });

  // Al hacer clic en dibujar rectángulo
  dibujarBtn.addEventListener('click', () => {
    // Desactivar polígono si está activo
    if (polygonDrawer) {
      polygonDrawer.disable();
      polygonDrawer = null;
    }

    // Crear y activar el dibujador de rectángulos
    L.drawLocal = L.drawLocal || {};
    L.drawLocal.draw = L.drawLocal.draw || {};
    L.drawLocal.draw.handlers = L.drawLocal.draw.handlers || {};

    L.drawLocal.draw.handlers.rectangle = {
      tooltip: {
        start: 'Haz clic y arrastra para dibujar un rectángulo'
      },
      shapeOptions: {
        color: '#3388ff'  // opcional, el color del rectángulo
      }
    };

    // Ahora sí inicializamos el drawer
    rectangleDrawer = new L.Draw.Rectangle(map);
    rectangleDrawer.enable();

    console.log('Modo dibujo de rectángulo activado');
  });

  // Al hacer clic en dibujar polígono
  poligonoBtn.addEventListener('click', () => {
    // Desactivar rectángulo si está activo
    if (rectangleDrawer) {
      rectangleDrawer.disable();
      rectangleDrawer = null;
    }

    // Crear y activar el dibujador de polígonos
    // Configurar mensajes en español para polígonos
    L.drawLocal = L.drawLocal || {};
    L.drawLocal.draw = L.drawLocal.draw || {};
    L.drawLocal.draw.handlers = L.drawLocal.draw.handlers || {};

    L.drawLocal.draw.handlers.polygon = {
      tooltip: {
        start: 'Haz clic para empezar a dibujar el polígono',   
        cont: 'Haz clic para continuar el polígono',          
        end: 'Haz clic en el primer punto para cerrar el polígono' 
      },
      shapeOptions: {
        color: '#3388ff' // opcional: color del polígono
      }
    };

    // Ahora inicializamos el drawer del polígono
    polygonDrawer = new L.Draw.Polygon(map);
    polygonDrawer.enable();


    console.log('Modo dibujo de polígono activado - Haz clic para añadir puntos, doble clic para terminar');
  });

  // Evento cuando se completa el dibujo
  map.on(L.Draw.Event.CREATED, (e) => {
    const layer = e.layer;
    drawnItems.addLayer(layer);
    console.log('Forma dibujada:', layer);
  });

  // Al hacer clic en aceptar
 // Al hacer clic en aceptar
  aceptarBtn.addEventListener('click', async () => {
    // Obtener todos los dibujos actuales
    const dibujos = [];
    
    drawnItems.eachLayer((layer) => {
      const geoJSON = layer.toGeoJSON();
      const tipo = layer instanceof L.Rectangle ? 'rectangulo' : 'poligono';
      
      dibujos.push({
        geojson: geoJSON,
        tipo: tipo
      });
    });

    // Si hay dibujos, enviarlos al backend
    if (dibujos.length > 0) {
  try {
    const response = await fetch('/api/guardar-dibujos', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ dibujos: dibujos })
    });

    const data = await response.json();

    if (!response.ok) {
      NotificationSystem.show({
        type: "error",
        title: "No se pudo guardar",
        message: data.error || "Ocurrió un error al guardar los dibujos"
      });
      return;
    }

    // ✅ Mostrar éxito
    NotificationSystem.show({
      type: "success",
      title: "Dibujo guardado",
      message: data.message || "Dibujo/s creado/s correctamente"
    });

  } catch (error) {
    console.error('Error en la petición:', error);
    NotificationSystem.show({
      type: "error",
      title: "Error de conexión",
      message: "No se pudo conectar con el servidor"
    });
  }
}




    // Continúa con el código original
    dibujarBtn.classList.add('hidden');
    poligonoBtn.classList.add('hidden');
    aceptarBtn.classList.add('hidden');
    cancelarBtn.classList.add('hidden');
    limpiarBtn.classList.add('hidden');
    editarBtn.classList.remove('hidden');

    modoEdicion = false;
    toggleInteraccionRecintos(true);

    if (rectangleDrawer) {
      rectangleDrawer.disable();
      rectangleDrawer = null;
    }
    if (polygonDrawer) {
      polygonDrawer.disable();
      polygonDrawer = null;
    }

    console.log('Cambios guardados');
  });


  // Al hacer clic en cancelar
  cancelarBtn.addEventListener('click', () => {
    dibujarBtn.classList.add('hidden');
    poligonoBtn.classList.add('hidden');
    aceptarBtn.classList.add('hidden');
    cancelarBtn.classList.add('hidden');
    limpiarBtn.classList.add('hidden');
    editarBtn.classList.remove('hidden');

    // Desactivar modo edición y reactivar interacción
    modoEdicion = false;
    toggleInteraccionRecintos(true);

    // Desactiva ambos modos de dibujo
    if (rectangleDrawer) {
      rectangleDrawer.disable();
      rectangleDrawer = null;
    }
    if (polygonDrawer) {
      polygonDrawer.disable();
      polygonDrawer = null;
    }

    // Restaurar estado anterior (eliminar dibujos nuevos)
    drawnItems.clearLayers();
    dibujosTemporales.forEach(layer => {
      drawnItems.addLayer(layer);
    });

    console.log('Edición cancelada');
  });

  // Al hacer clic en limpiar
  limpiarBtn.addEventListener('click', () => {
    // Eliminar todos los dibujos
    drawnItems.clearLayers();
  });
 


  actualizarMapaSegunZoom();
  cargarRecintosSiProcede();
  cargarMisRecintosSiProcede();

  // Intentar restaurar el estado guardado.
  // Si no hay estado guardado, centrar en el municipio donde el usuario tiene más "mis recintos".
  map.whenReady(async function () {
    if (!recintoData) {
      const restaurado = await restaurarEstadoMapa();
      if (!restaurado) {
        await aplicarVistaInicialUsuario();
      }
    }
  });










const dibujosToggle = document.getElementById('dibujos-toggle');
const dibujosPanel = document.getElementById('dibujos-panel');
const dibujosList = document.getElementById('dibujos-list');
const dibujosCount = document.getElementById('dibujos-count');
const refrescarDibujosBtn = document.getElementById('refrescar-dibujos');

// FeatureGroup para los dibujos guardados
const dibujosGuardadosLayer = new L.FeatureGroup();
map.addLayer(dibujosGuardadosLayer);

// Toggle panel
dibujosToggle.addEventListener('click', () => {
  dibujosPanel.classList.toggle('hidden');
});



// Función para formatear fecha
function formatearFechaDibujo(fechaISO) {
  const fecha = new Date(fechaISO);
  const ahora = new Date();
  const diff = ahora - fecha;
  const dias = Math.floor(diff / (1000 * 60 * 60 * 24));
  
  if (dias === 0) return 'Hoy';
  if (dias === 1) return 'Ayer';
  if (dias < 7) return `Hace ${dias} días`;
  
  return fecha.toLocaleDateString('es-ES', { 
    day: '2-digit', 
    month: '2-digit', 
    year: 'numeric' 
  });
}

let dibujoVisibleId = null;

// Función para cargar dibujos guardados
async function cargarDibujosGuardados() {
  try {
    const response = await fetch('/api/obtener-dibujos');
    const data = await response.json();
    
    if (!response.ok) {
      console.error('Error al obtener dibujos:', data.error);
      return;
    }
    
    const dibujos = data.dibujos || [];
    
    // Actualizar contador
    dibujosCount.textContent = dibujos.length;
    dibujosCount.style.display = dibujos.length > 0 ? 'block' : 'none';
    
    // Limpiar lista y capa
    dibujosList.innerHTML = '';
    dibujosGuardadosLayer.clearLayers();
    dibujoVisibleId = null;
    
    if (dibujos.length === 0) {
      dibujosList.innerHTML = `
        <div class="dibujos-empty">
          <i class="bi bi-bookmark" style="font-size:48px;opacity:0.3;"></i>
          <p style="margin:16px 0 0 0;font-size:14px;">No hay dibujos guardados</p>
        </div>
      `;
      return;
    }
    
    // Header con botón mostrar/ocultar todos
    const headerActions = document.createElement('div');
    headerActions.className = 'dibujos-list-header';
    headerActions.innerHTML = `
      <button class="dibujo-btn-toggle-all" id="toggle-all-dibujos">
        <i class="bi bi-eye-fill"></i> Mostrar todos
      </button>
    `;
    dibujosList.appendChild(headerActions);
    
    let todosVisibles = false;
    
    // Renderizar cada dibujo
    dibujos.forEach((dibujo, index) => {
      const geojson = typeof dibujo.geojson === 'string' 
        ? JSON.parse(dibujo.geojson) 
        : dibujo.geojson;
      
      const item = document.createElement('div');
      item.className = 'dibujo-item';
      item.dataset.dibujoId = dibujo.id;
      
      const colors = [
        '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A',
        '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2',
        '#F8B739', '#52B788', '#EF476F', '#06D6A0', 
        '#118AB2', '#FFD166', '#8338EC', '#3A86FF', 
        '#FFBE0B', '#FB5607', '#2EC4B6', '#90DBF4'
      ];

      const color = colors[index % colors.length];
      
      item.innerHTML = `
        <div class="dibujo-content">
          <div class="dibujo-color" style="background-color: ${color};"></div>
          
          <div class="dibujo-info">
            <div class="dibujo-ndvi-compact">
              <div class="ndvi-compact-item">
                <span class="ndvi-label">Máx</span>
                <span class="ndvi-value">${dibujo.ndvi_max?.toFixed(2) || '-'}</span>
              </div>
              <div class="ndvi-compact-item">
                <span class="ndvi-label">Min</span>
                <span class="ndvi-value">${dibujo.ndvi_min?.toFixed(2) || '-'}</span>
              </div>
              <div class="ndvi-compact-item">
                <span class="ndvi-label">Med</span>
                <span class="ndvi-value">${dibujo.ndvi_medio?.toFixed(2) || '-'}</span>
              </div>
            </div>
            
            ${dibujo.area_m2 ? `
              <div class="dibujo-area">
                ${(dibujo.area_m2 / 10000).toFixed(2)} ha
              </div>
            ` : ''}
          </div>
          
          <div class="dibujo-actions-compact">
            <button class="dibujo-btn-icon delete-btn" data-id="${dibujo.id}" title="Eliminar">
              <i class="bi bi-trash-fill"></i>
            </button>
          </div>
        </div>
      `;
      
      dibujosList.appendChild(item);
      
      // Añadir geometría al mapa con el color correspondiente
      const layer = L.geoJSON(geojson, {
        style: {
          color: color,
          weight: 5,
          opacity: 0,
          fillColor: color,
          fillOpacity: 0
        },
        // CRÍTICO: Evitar que los eventos se propaguen a capas inferiores
        bubblingMouseEvents: false,
        pane: 'highlightPane', // Usar el pane de mayor z-index
        interactive: false // Inicialmente no interactivo porque está oculto
      });
      
      layer.dibujoId = dibujo.id;
      layer.dibujoColor = color;
      layer.colorOriginal = color;
      
      // Crear contenido del popup COMPACTO
      const popupContent = `
        <div style="font-family: inherit; min-width: 180px;">
          <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 2px solid ${color};">
            <div style="width: 4px; height: 20px; background: ${color}; border-radius: 2px;"></div>
            <h6 style="margin: 0; font-size: 13px; font-weight: 700; color: #333;">Consulta</h6>
          </div>
          
          <div style="display: flex; gap: 8px; margin-bottom: 6px;">
            <div style="flex: 1; background: #f8f9fa; padding: 6px; border-radius: 6px; text-align: center;">
              <div style="font-size: 9px; color: #666; font-weight: 600;">MAX</div>
              <div style="font-size: 14px; font-weight: 700; color: #198754;">${dibujo.ndvi_max?.toFixed(2) || '-'}</div>
            </div>
            <div style="flex: 1; background: #f8f9fa; padding: 6px; border-radius: 6px; text-align: center;">
              <div style="font-size: 9px; color: #666; font-weight: 600;">MIN</div>
              <div style="font-size: 14px; font-weight: 700; color: #198754;">${dibujo.ndvi_min?.toFixed(2) || '-'}</div>
            </div>
            <div style="flex: 1; background: #f8f9fa; padding: 6px; border-radius: 6px; text-align: center;">
              <div style="font-size: 9px; color: #666; font-weight: 600;">MED</div>
              <div style="font-size: 14px; font-weight: 700; color: #198754;">${dibujo.ndvi_medio?.toFixed(2) || '-'}</div>
            </div>
          </div>
          
          ${dibujo.area_m2 ? `
            <div style="background: #e7f5ff; padding: 6px; border-radius: 6px; text-align: center;">
              <span style="font-size: 14px; font-weight: 700; color: #1976d2;">${(dibujo.area_m2 / 10000).toFixed(2)} ha</span>
              <span style="font-size: 10px; color: #666; margin-left: 4px;">(${dibujo.area_m2.toFixed(0)} m²)</span>
            </div>
          ` : ''}
        </div>
      `;
      
      // Hacer la capa interactiva con popup
      layer.eachLayer(function(l) {
        l.dibujoId = dibujo.id;
        l.isDibujoGuardado = true;
        
        // NUEVO: Configurar para que no burbujeen los eventos
        l.options.bubblingMouseEvents = false;
        l.options.interactive = false; // Inicialmente no interactivo
        
        if (l.setStyle) {
          l.setStyle({ className: 'dibujo-clickeable' });
        }
        
        // Añadir popup
        l.bindPopup(popupContent, {
          maxWidth: 250,
          className: 'dibujo-popup',
          autoPan: true
        });
        
        // Click handler - solo abrir popup, sin cambiar visibilidad
        l.on('click', function(e) {
          // Prevenir propagación
          if (e && e.originalEvent) {
            e.originalEvent._stopped = true;
          }
          
          // Solo abrir popup si el dibujo está visible
          const currentStyle = this.options;
          if (currentStyle.opacity > 0 && currentStyle.interactive) {
            this.openPopup();
          }
          
          return false;
        }, null, true);
        
        // Efectos hover - SOLO si el dibujo está visible
        l.on('mouseover', function(e) {
          const currentOpacity = this.options.opacity || 0;
          
          // Solo aplicar hover si está visible E interactivo
          if (currentOpacity > 0 && this.options.interactive && this.setStyle) {
            const currentWeight = this.options.weight || 3;
            const currentFill = this.options.fillOpacity || 0.3;
            
            this.setStyle({ 
              weight: currentWeight + 2, 
              fillOpacity: Math.min(currentFill + 0.1, 0.5)
            });
          }
          return false;
        });
        
        l.on('mouseout', function(e) {
          const currentOpacity = this.options.opacity || 0;
          
          // Solo resetear hover si está visible E interactivo
          if (currentOpacity > 0 && this.options.interactive && this.setStyle) {
            const isActive = dibujoVisibleId === dibujo.id;
            this.setStyle({ 
              weight: isActive ? 4 : 3,
              fillOpacity: isActive ? 0.35 : 0.3
            });
          }
          return false;
        });
      });
      
      dibujosGuardadosLayer.addLayer(layer);
      
      // Evento eliminar
      item.querySelector('.delete-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        eliminarDibujo(dibujo.id);
      });
      
      // Click en el item para toggle visibilidad (solo uno a la vez)
      item.addEventListener('click', () => {
  // Verificar si "mostrar todos" está activo
  const btnToggleAll = document.getElementById('toggle-all-dibujos');
  const mostrandoTodos = btnToggleAll && btnToggleAll.textContent.includes('Ocultar todos');
  
  if (mostrandoTodos) {
    // Si están todos visibles, solo resaltar sin ocultar los demás
    resaltarDibujoSinOcultar(dibujo.id, item);
  } else {
    // Si no están todos visibles, comportamiento normal (mostrar solo uno)
    resaltarDibujo(dibujo.id, item);
  }
});
    });
    

    // Añade esta función ANTES de la función "resaltarDibujo":
// Busca la función resaltarDibujoSinOcultar y reemplázala completamente por esta:
function resaltarDibujoSinOcultar(id, itemElement) {
  // Quitar clase active de todos los items
  document.querySelectorAll('.dibujo-item').forEach(item => {
    item.classList.remove('active');
  });
  
  // Añadir clase active al item seleccionado
  itemElement.classList.add('active');
  dibujoVisibleId = id;
  
  // Mantener todos visibles pero resaltar el seleccionado
  dibujosGuardadosLayer.eachLayer(layer => {
    if (layer.dibujoId === id) {
      // Resaltar este con máxima visibilidad
      layer.setStyle({ 
        opacity: 1,
        fillOpacity: 0.45,
        weight: 5
      });
      
      // Activar interactividad
      layer.eachLayer(l => {
        l.options.interactive = true;
        if (l._path) {
          l._path.style.pointerEvents = 'auto';
        }
      });
      
      // Hacer zoom
      map.fitBounds(layer.getBounds(), {
        padding: [50, 50],
        maxZoom: 16
      });
      
      // Abrir popup automáticamente
      setTimeout(() => {
        layer.eachLayer(l => {
          if (l.getPopup) {
            l.openPopup();
          }
        });
      }, 300);
      
    } else {
      // Mantener visibles los demás pero con opacidad original (0.9)
      layer.setStyle({ 
        opacity: 0.9,
        fillOpacity: 0.3,
        weight: 3
      });
      
      // Mantener interactividad de todos
      layer.eachLayer(l => {
        l.options.interactive = true;
        if (l._path) {
          l._path.style.pointerEvents = 'auto';
        }
      });
    }
  });
}
    // Toggle todos
    const toggleAllBtn = document.getElementById('toggle-all-dibujos');
    if (toggleAllBtn) {
      toggleAllBtn.addEventListener('click', function() {
        todosVisibles = !todosVisibles;
        
        // Quitar el activo individual
        dibujoVisibleId = null;
        document.querySelectorAll('.dibujo-item').forEach(item => {
          item.classList.remove('active');
        });
        
        dibujosGuardadosLayer.eachLayer(layer => {
          if (todosVisibles) {
            // Mostrar todos
            layer.setStyle({ 
              opacity: 0.9,
              fillOpacity: 0.3
            });
            
            // CRÍTICO: Activar interactividad para todos
            layer.eachLayer(l => {
              l.options.interactive = true;
              if (l._path) {
                l._path.style.pointerEvents = 'auto';
              }
            });
          } else {

  map.closePopup();

  // Ocultar todos
  layer.setStyle({ 
    opacity: 0, 
    fillOpacity: 0 
  });

  // Desactivar interactividad
  layer.eachLayer(l => {
    l.options.interactive = false;
    if (l._path) {
      l._path.style.pointerEvents = 'none';
    }
  });
}
        });
        
        this.innerHTML = todosVisibles 
          ? '<i class="bi bi-eye-slash-fill"></i> Ocultar todos'
          : '<i class="bi bi-eye-fill"></i> Mostrar todos';
      });
    }
    
  } catch (error) {
    console.error('Error al cargar dibujos:', error);
  }
}

// Resaltar dibujo al hacer click en la lista (sin ocultarlo)
function resaltarDibujo(id, itemElement) {
  // Quitar clase active de todos los items
  document.querySelectorAll('.dibujo-item').forEach(item => {
    item.classList.remove('active');
  });
  
  // Añadir clase active al item seleccionado
  itemElement.classList.add('active');
  dibujoVisibleId = id;
  
  // OCULTAR TODOS primero, luego mostrar solo el seleccionado
  dibujosGuardadosLayer.eachLayer(layer => {
    if (layer.dibujoId === id) {
      // Mostrar solo este con máxima visibilidad Y hacerlo interactivo
      layer.setStyle({ 
        opacity: 1,
        fillOpacity: 0.45,
        weight: 5
      });
      
      // CRÍTICO: Activar interactividad
      layer.eachLayer(l => {
        l.options.interactive = true;
        if (l._path) {
          l._path.style.pointerEvents = 'auto';
        }
      });
      
      // Hacer zoom
      map.fitBounds(layer.getBounds(), {
        padding: [50, 50],
        maxZoom: 16
      });
      
      // Abrir popup automáticamente
      setTimeout(() => {
        layer.eachLayer(l => {
          if (l.getPopup) {
            l.openPopup();
          }
        });
      }, 300);
      
    } else {
  // Mantener visibles los demás, pero atenuados
  layer.setStyle({ 
    opacity: 0.4,
    fillOpacity: 0.15,
    weight: 3
  });

  // Siguen siendo interactivos si quieres
  layer.eachLayer(l => {
    l.options.interactive = true;
    if (l._path) {
      l._path.style.pointerEvents = 'auto';
    }
  });
}
  });
}

// Toggle al hacer click (mantener por compatibilidad pero ya no se usa mucho)
function toggleDibujoClick(id, itemElement) {
  const wasVisible = (dibujoVisibleId === id);
  
  // Quitar clase active de todos los items
  document.querySelectorAll('.dibujo-item').forEach(item => {
    item.classList.remove('active');
  });
  
  // Ocultar todos los dibujos
  dibujosGuardadosLayer.eachLayer(layer => {
    layer.setStyle({ opacity: 0, fillOpacity: 0 });
  });
  
  if (wasVisible) {
    // Si ya estaba visible, ocultarlo
    dibujoVisibleId = null;
  } else {
    // Mostrar solo este con mayor visibilidad
    dibujoVisibleId = id;
    itemElement.classList.add('active');
    
    dibujosGuardadosLayer.eachLayer(layer => {
      if (layer.dibujoId === id) {
        layer.setStyle({ 
          opacity: 1,           // Aumentado de 0.8 a 1
          fillOpacity: 0.35,    // Aumentado de 0.25 a 0.35
          weight: 4             // Aumentado de 3 a 4
        });
        
        // Hacer zoom
        map.fitBounds(layer.getBounds(), {
          padding: [50, 50],
          maxZoom: 16
        });
      }
    });
  }
}

// Eliminar dibujo
window.eliminarDibujo = async function(id) {

  const ok = await AppConfirm.open({
    title: "Eliminar dibujo",
    message: "¿Estás seguro de que deseas eliminar este dibujo?",
    okText: "Eliminar",
    cancelText: "Cancelar",
    okClass: "btn-danger"
  });

  if (!ok) return;

  try {
    const response = await fetch(`/api/eliminar-dibujo/${id}`, {
      method: 'DELETE'
    });

    if (response.ok) {

      // Limpiar estado si estaba visible
      if (dibujoVisibleId === id) {
        dibujoVisibleId = null;
        map.closePopup();
      }

      cargarDibujosGuardados();

      // ✅ NOTIFICACIÓN
      NotificationSystem.show({
        type: "success",
        title: "Dibujo eliminado",
        message: "El dibujo se eliminó correctamente"
      });

    } else {
      alert('Error al eliminar');
    }

  } catch (error) {
    console.error('Error:', error);
  }
};

// Cargar al inicio
cargarDibujosGuardados();

// CORRECCIÓN PRINCIPAL: Recargar después de guardar con limpieza de estado
if (typeof aceptarBtn !== 'undefined') {
  const originalClickHandler = aceptarBtn.onclick;
  
  aceptarBtn.addEventListener('click', function(e) {
    // Ejecutar el handler original si existe
    if (originalClickHandler) {
      originalClickHandler.call(this, e);
    }
    
    // Recargar dibujos después de un delay
    setTimeout(() => {
      cargarDibujosGuardados();
      
      // CRÍTICO: Limpiar el estado del modo de dibujo
      if (typeof drawnItems !== 'undefined') {
        drawnItems.clearLayers();
      }
      
      // Resetear variables globales si existen
      if (typeof currentLayer !== 'undefined') {
        currentLayer = null;
      }
      
      // Deshabilitar herramientas de dibujo activas
      if (typeof drawControl !== 'undefined' && map.hasLayer(drawControl)) {
        map.removeControl(drawControl);
        // Volver a añadir el control limpio
        if (typeof L.Control.Draw !== 'undefined') {
          map.addControl(drawControl);
        }
      }
      
      // NUEVO: Activar automáticamente "mostrar todos" después de guardar
      setTimeout(() => {
        const btnToggleAll = document.getElementById('toggle-all-dibujos');
        if (btnToggleAll && btnToggleAll.textContent.includes('Mostrar todos')) {
          btnToggleAll.click();
        }
      }, 100);
    }, 1000);
  });
}

// NUEVO: Hacer los dibujos guardados clickeables en el mapa
// Ahora con prevención de conflictos con recintos
dibujosGuardadosLayer.on('click', function(e) {
  // Solo procesar si realmente se hizo clic en un dibujo guardado
  if (!e.layer || !e.layer.isDibujoGuardado) return;
  
  const clickedLayer = e.layer;
  const dibujoId = clickedLayer.dibujoId;
  
  if (dibujoId) {
    // Encontrar el item correspondiente en la lista
    const item = document.querySelector(`.dibujo-item[data-dibujo-id="${dibujoId}"]`);
    if (item) {
      // Hacer scroll al item en la lista
      item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      
      // Resaltar el dibujo
      resaltarDibujo(dibujoId, item);
    }
  }
});
  });
</script>
<script src="{{ url_for('static', filename='js/visor/visor-cultivos.js') }}"></script>
<script src="{{ url_for('static', filename='js/visor/visor-operaciones.js') }}"></script>

{% endblock %}