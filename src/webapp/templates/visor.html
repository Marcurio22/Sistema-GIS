{% extends "base.html" %}

{% block title %}Visor SIG{% endblock %}

{% block navbar_extra %}
<div class="d-flex align-items-center gap-3 bg-white rounded-3 px-3 py-2 shadow-sm">
  <!-- Temperatura principal -->
  <div class="d-flex align-items-center">
    <i class="bi bi-{{ weather.icono }} {{ weather.color_icono }}" style="font-size: 1.5rem;"></i>
    <span class="ms-2 fw-bold fs-5 text-dark">{{ weather.temperatura }}°</span>
  </div>

  <!-- Separador -->
  <div class="vr opacity-50"></div>

  <!-- Datos compactos -->
  <div class="d-none d-md-flex gap-3 small text-dark">
    {% if weather.humedad %}
    <div class="d-flex align-items-center">
      <i class="bi bi-droplet-fill text-info me-1"></i>
      <span>{{ weather.humedad }}%</span>
    </div>
    {% endif %}

    {% if weather.viento_velocidad %}
    <div class="d-flex align-items-center">
      <i class="bi bi-wind text-secondary me-1"></i>
      <span>{{ weather.viento_velocidad }} km/h</span>
    </div>
    {% endif %}

    {% if weather.prob_precipitacion %}
    <div class="d-flex align-items-center">
      <i class="bi bi-cloud-rain text-primary me-1"></i>
      <span>{{ weather.prob_precipitacion }}%</span>
    </div>
    {% endif %}
  </div>

  <!-- Ubicación (solo en pantallas grandes) -->
  <div class="d-none d-lg-block text-muted small">
    <i class="bi bi-geo-alt-fill"></i> {{ weather.municipio }}
  </div>
</div>
<div id="notification-container"></div>
{% endblock %}

{% block content %}

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />

<style>
  /* El mapa ocupa toda la ventana menos la barra verde superior */
  html,
  body {
    height: 100%;
  }

  #editar-container {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 1000;
    font-family: inherit;
  }

  /* Botón flotante estilo basemap/filtro */
  #editar-btn {
    width: 48px;
    height: 48px;
    border-radius: 12px;
    border: none;
    background-color: #198754;
    /* mismo verde que otros botones */
    color: #ffffff;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition:
      background-color 0.2s ease,
      transform 0.16s ease-out,
      box-shadow 0.2s ease;
  }

  #editar-btn i {
    font-size: 22px;
  }

  #editar-btn:hover {
    transform: translateY(-1px) scale(1.04);
    box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
  }

  #editar-btn:active {
    transform: scale(0.96);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
  }


  #map {
    position: fixed;
    top: 65px;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
  }

  /* ---------- Contenedores de botones ---------- */
  #basemap-panel-container,
  #filtro-container {
    position: fixed;
    z-index: 1000;
    font-family: inherit;
    transition: right 0.25s ease-out;
  }

  #basemap-panel-container {
    top: 80px;
    right: 20px;
  }

  #filtro-container {
    top: 150px;
    right: 20px;
  }

  /* Cuando el panel de capas está abierto, ambos contenedores se desplazan */
  #basemap-panel-container.panel-open,
  #filtro-container.panel-open {
    right: 530px;
  }

  /* ---------- Botones flotantes ---------- */
  #basemap-toggle,
  #filtro-toggle {
    width: 48px;
    height: 48px;
    border-radius: 12px;
    border: none;
    background-color: #198754;
    color: #ffffff;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition:
      background-color 0.2s ease,
      transform 0.16s ease-out,
      box-shadow 0.2s ease;
  }

  #basemap-toggle i,
  #filtro-toggle i {
    font-size: 22px;
  }

  #basemap-toggle:not(.active),
  #filtro-toggle:not(.active) {
    background-color: #ffffff;
    color: #198754;
  }

  #basemap-toggle:hover,
  #filtro-toggle:hover {
    transform: translateY(-1px) scale(1.04);
    box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
  }

  #basemap-toggle:active,
  #filtro-toggle:active {
    transform: scale(0.96);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
  }

  #basemap-toggle.active,
  #filtro-toggle.active {
    background-color: #198754;
    color: #ffffff;
  }

  /* ---------- Panel ---------- */
  #basemap-panel {
    position: fixed;
    top: 80px;
    right: 20px;
    width: 420px;
    max-height: 75vh;
    background-color: #ffffff;
    box-shadow:
      0 10px 30px rgba(15, 23, 42, 0.35),
      0 1px 0 rgba(255, 255, 255, 0.5);
    border-radius: 18px;
    padding: 16px 20px 20px;
    overflow: hidden;
    opacity: 0;
    transform: translateX(100%) translateY(-8px);
    pointer-events: none;
    transition:
      transform 0.25s ease-out,
      opacity 0.22s ease-out;
    z-index: 999;
  }

  #basemap-panel.visible {
    opacity: 1;
    transform: translateX(-80px) translateY(0);
    pointer-events: auto;
  }

  #basemap-panel h6 {
    font-size: 1.15rem;
    font-weight: 700;
    margin-top: 10px;
    margin-bottom: 10px;
  }

  .basemap-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 14px;
    margin-bottom: 14px;
  }

  .basemap-option {
    width: 100%;
    cursor: pointer;
    text-align: center;
    font-size: 0.95rem;
    color: #333;
    transition:
      transform 0.18s ease-out,
      box-shadow 0.18s ease-out;
  }

  .basemap-thumb {
    width: 100%;
    height: 115px;
    border-radius: 12px;
    border: 3px solid transparent;
    overflow: hidden;
    background-size: cover;
    background-position: center;
    margin-bottom: 6px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.20);
    transition:
      border-color 0.18s ease-out,
      box-shadow 0.18s ease-out,
      transform 0.18s ease-out;
  }

  .basemap-thumb img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }

  .basemap-option-label {
    line-height: 1.25;
    font-size: 0.9rem;
    font-weight: 500;
  }

  .basemap-option:not(.disabled):hover .basemap-thumb {
    transform: translateY(-2px);
    box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
  }

  .basemap-option:not(.disabled):hover {
    transform: translateY(-2px);
  }

  .basemap-option.active .basemap-thumb {
    border-color: #198754;
  }

  .basemap-option.disabled {
    opacity: 0.45;
    cursor: default;
    pointer-events: none;
  }

  /* --------- Responsive: móviles / pantallas pequeñas ---------- */
  @media (max-width: 576px) {

    #basemap-panel-container,
    #filtro-container {
      right: 10px;
    }

    #basemap-panel-container.panel-open,
    #filtro-container.panel-open {
      right: 10px;
    }

    #basemap-panel {
      width: calc(100vw - 20px);
      right: 10px;
    }

    #basemap-panel.visible {
      transform: translateX(0) translateY(0);
    }

    .basemap-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  #notification-container {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10000;
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-width: 400px;
  }

  .notification {
    background: white;
    padding: 18px 20px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
    display: flex;
    align-items: flex-start;
    gap: 14px;
    animation: slideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    border-left: 4px solid;
    position: relative;
    overflow: hidden;
  }

  .notification.removing {
    animation: slideOut 0.3s ease forwards;
  }

  /* Animación centrada desde arriba */
  @keyframes slideIn {
    from {
      transform: translate(-50%, -40px);
      opacity: 0;
    }

    to {
      transform: translate(-50%, 0);
      opacity: 1;
    }
  }

  @keyframes slideOut {
    to {
      transform: translate(-50%, -40px);
      opacity: 0;
    }
  }

  .notification-icon {
    flex-shrink: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    font-weight: bold;
    font-size: 16px;
  }

  .notification-content {
    flex: 1;
  }

  .notification-title {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 4px;
    color: #1a1a1a;
  }

  .notification-message {
    font-size: 14px;
    color: #666;
    line-height: 1.4;
  }

  .notification-close {
    flex-shrink: 0;
    width: 20px;
    height: 20px;
    border: none;
    background: transparent;
    color: #999;
    cursor: pointer;
    font-size: 18px;
    line-height: 1;
    padding: 0;
    transition: color 0.2s;
  }

  .notification-close:hover {
    color: #333;
  }

  .notification-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 3px;
    background: currentColor;
    opacity: 0.3;
    animation: progress 5s linear forwards;
  }

  @keyframes progress {
    from {
      width: 100%;
    }

    to {
      width: 0%;
    }
  }

  /* Tipos */
  .notification.success {
    border-left-color: #198754;
  }

  .notification.success .notification-icon {
    background: #d1f4e0;
    color: #198754;
  }

  .notification.success .notification-progress {
    color: #198754;
  }

  .notification.error {
    border-left-color: #dc3545;
  }

  .notification.error .notification-icon {
    background: #f8d7da;
    color: #dc3545;
  }

  .notification.error .notification-progress {
    color: #dc3545;
  }

  .notification.warning {
    border-left-color: #ffc107;
  }

  .notification.warning .notification-icon {
    background: #fff3cd;
    color: #856404;
  }

  .notification.warning .notification-progress {
    color: #ffc107;
  }

  .notification.info {
    border-left-color: #0dcaf0;
  }

  .notification.info .notification-icon {
    background: #cff4fc;
    color: #055160;
  }

  .notification.info .notification-progress {
    color: #0dcaf0;
  }

  /* Responsive */
  @media (max-width: 576px) {
    #notification-container {
      left: 50%;
      right: auto;
      transform: translateX(-50%);
      top: 70px;
      max-width: calc(100% - 20px);
    }

    @keyframes slideIn {
      from {
        transform: translate(-50%, -60px);
        opacity: 0;
      }

      to {
        transform: translate(-50%, 0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      to {
        transform: translate(-50%, -60px);
        opacity: 0;
      }
    }

  }


  /* Dibujar? */
  .hidden {
    display: none !important;
  }

  #editar-container {
    display: flex;
    gap: 8px;
  }

  #editar-container button {
    border: none;
    padding: 10px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 18px;
    transition: all 0.3s ease;
  }

  #dibujar-btn {
    background: white;
    color: #28a745;
  }

  #poligono-btn {
    background: white;
    color: #28a745;
  }

  #aceptar-btn {
    background: #28a745;
    color: white;
  }

  #cancelar-btn {
    background: #dc3545;
    color: white;
  }

  #editar-container button:hover {
    opacity: 0.9;
    transform: scale(1.05);
  }
</style>

<div id="map"></div>

<!-- Botón de capas -->
<div id="basemap-panel-container">
  <button id="basemap-toggle" title="Capas">
    <i class="bi bi-layers-fill"></i>
  </button>
</div>

<!-- Panel de capas -->
<div id="basemap-panel">
  <h6>Mapa Principal</h6>
  <div class="basemap-grid">
    <div class="basemap-option basemap-main active" data-layer="satellite">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_satellite.png') }}" alt="Imagen satélite" />
      </div>
      <div class="basemap-option-label">Imagen<br>Satelital</div>
    </div>

    <div class="basemap-option basemap-main" data-layer="ndvi">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_ndvi.png') }}" alt="Vigor Vegetal (NDVI)" />
      </div>
      <div class="basemap-option-label">Vigor Vegetal<br>(NDVI)</div>
    </div>

    <div class="basemap-option disabled">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_etp.png') }}" alt="ETP" />
      </div>
      <div class="basemap-option-label">ETP</div>
    </div>
  </div>

  <h6>Nivel de Detalle</h6>
  <div class="basemap-grid">
    <div class="basemap-option basemap-detail active" data-detail="mis">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_mis_recintos.png') }}" alt="Mis Recintos" />
      </div>
      <div class="basemap-option-label">Mis Recintos</div>
    </div>

    <div class="basemap-option basemap-detail active" data-detail="sigpac">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_recintos.png') }}" alt="Recintos SigPac" />
      </div>
      <div class="basemap-option-label">Recintos SigPac</div>
    </div>

    <div class="basemap-option disabled">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_calculadas.png') }}" alt="Recintos Calculadas" />
      </div>
      <div class="basemap-option-label">recintos<br>Calculadas</div>
    </div>
  </div>
</div>


<!-- Botón de filtros -->
<div id="filtro-container">
  <button id="filtro-toggle" title="Filtros">
    <i class="bi bi-funnel-fill"></i>
  </button>
</div>

<div id="editar-container">
  <button id="dibujar-btn" class="hidden" title="Dibujar Rectángulo">
    <i class="bi bi-square"></i>
  </button>
  <button id="poligono-btn" class="hidden" title="Dibujar Polígono">
    <i class="bi bi-pentagon"></i>
  </button>
  <button id="editar-btn" title="Editar">
    <i class="bi bi-pencil-fill"></i>
  </button>
  <button id="aceptar-btn" class="hidden" title="Aceptar">
    <i class="bi bi-check-lg"></i>
  </button>
  <button id="limpiar-btn" class="hidden" title="Limpiar todo">
    <i class="bi bi-trash-fill"></i>
  </button>
  <button id="cancelar-btn" class="hidden" title="Cancelar">
    <i class="bi bi-x-lg"></i>
  </button>
</div>

<script>
  const NotificationSystem = {
    container: null,
    initialized: false,

    init() {
      if (this.initialized) return;

      this.container = document.getElementById('notification-container');

      if (!this.container) {
        console.error('❌ Contenedor #notification-container no encontrado en el DOM');
        // Crear el contenedor si no existe
        this.container = document.createElement('div');
        this.container.id = 'notification-container';
        document.body.appendChild(this.container);
        console.log('✅ Contenedor de notificaciones creado automáticamente');
      } else {
        console.log('✅ Sistema de notificaciones inicializado correctamente');
      }

      this.initialized = true;
    },

    show({ type = 'info', title, message, duration = 5000 }) {
      // Inicializar si no está listo
      if (!this.initialized) {
        this.init();
      }

      if (!this.container) {
        console.error('❌ No se pudo crear el contenedor de notificaciones');
        // Fallback a alert
        alert(`${title}\n${message}`);
        return;
      }

      const notification = document.createElement('div');
      notification.className = `notification ${type}`;

      const icons = {
        success: '✓',
        error: '✕',
        warning: '⚠',
        info: 'i'
      };

      notification.innerHTML = `
        <div class="notification-icon">${icons[type]}</div>
        <div class="notification-content">
          <div class="notification-title">${this.escapeHtml(title)}</div>
          <div class="notification-message">${this.escapeHtml(message)}</div>
        </div>
        <button class="notification-close" aria-label="Cerrar">×</button>
        <div class="notification-progress"></div>
      `;

      // Evento de cierre
      const closeBtn = notification.querySelector('.notification-close');
      closeBtn.addEventListener('click', () => this.close(closeBtn));

      this.container.appendChild(notification);

      // Auto-cierre
      if (duration > 0) {
        setTimeout(() => {
          this.close(closeBtn);
        }, duration);
      }
    },

    close(button) {
      const notification = button.closest('.notification');
      if (!notification) return;

      notification.classList.add('removing');
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 300);
    },

    // Escapar HTML para prevenir XSS
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };
  document.addEventListener("DOMContentLoaded", function () {
    NotificationSystem.init();

    // -----------------------------------------
    // 1) ROI desde Flask
    // -----------------------------------------
    const roiBbox = [
      {{ roi_bbox[0] }},
    {{ roi_bbox[1] }},
    {{ roi_bbox[2] }},
    {{ roi_bbox[3] }}
    ];

  const ROI_BOUNDS = L.latLngBounds(
    [roiBbox[1], roiBbox[0]],
    [roiBbox[3], roiBbox[2]]
  );

  const ZOOM_RECINTOS = 15;

  // -----------------------------------------
  // 2) Crear mapa
  // -----------------------------------------
  const map = L.map("map", {
    maxBounds: ROI_BOUNDS,
    maxBoundsViscosity: 1.0,
    zoomControl: true,
  });

  map.fitBounds(ROI_BOUNDS);

  // --- Panes (orden de dibujo) ---
  map.createPane('sigpacPane');
  map.getPane('sigpacPane').style.zIndex = 400;

  map.createPane('misPane');
  map.getPane('misPane').style.zIndex = 450;

  map.createPane('highlightPane');
  map.getPane('highlightPane').style.zIndex = 650;

  // -----------------------------------------
  // 3) Capas base
  // -----------------------------------------
  const baseOSM = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    {
      attribution: "&copy; OpenStreetMap contributors",
      minZoom: 8,
      maxZoom: 19,
    }
  ).addTo(map);

  const baseSat = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    {
      attribution: "Tiles &copy; Esri",
      minZoom: 8,
      maxZoom: 19,
    }
  );

  const baseNdvi = L.imageOverlay(
    "/static/ndvi/ndvi_latest.png",
    ROI_BOUNDS,
    { opacity: 1.0 }
  );

  const highZoomLayers = {
    satellite: baseSat,
    ndvi: baseNdvi
  };

  let activeHighLayerKey = "satellite";
  function getActiveHighLayer() {
    return highZoomLayers[activeHighLayerKey];
  }

  // -----------------------------------------
  // 4) Capa de recintos
  // -----------------------------------------

  const RECINTO_STYLE_DEFAULT = {
    color: "#ff8800",
    weight: 1,
  };

  const RECINTO_STYLE_SELECTED = {
    color: "#0077ff",
    weight: 2,
    fillOpacity: 0.25,
  };

  let selectedRecintoLayer = null;

  const recintosLayer = L.geoJSON(null, {
    pane: 'sigpacPane',
    style: function () {
      return RECINTO_STYLE_DEFAULT;
    },
    onEachFeature: function (feature, layer) {
      const p = feature.properties || {};

      // Propietario: username o "N/A"
      const propietarioTexto =
        p.propietario && String(p.propietario).trim() !== ""
          ? p.propietario
          : "N/A";

      const tienePropietario = propietarioTexto !== "N/A";
      const disabledAttr = tienePropietario ? "disabled" : "";
      const disabledStyle = tienePropietario
        ? "opacity: 0.5; cursor: not-allowed;"
        : "";

      const html = `
        <div class="popup-recinto">
          <div class="popup-recinto-info">
            <strong>Provincia:</strong> ${p.provincia ?? "-"}<br>
            <strong>Municipio:</strong> ${p.municipio ?? "-"}<br>
            <strong>Polígono:</strong> ${p.poligono ?? "-"}<br>
            <strong>Parcela:</strong> ${p.parcela ?? "-"}<br>
            <strong>Recinto:</strong> ${p.recinto ?? "-"}<br>
            <strong>Propietario:</strong> ${propietarioTexto}
          </div>
          <div style="margin-top: 10px; text-align: right;">
            <button
              type="button"
              class="btn-add-recinto"
              data-id-recinto="${p.id_recinto ?? ""}"
              data-provincia="${p.provincia ?? ""}"
              data-municipio="${p.municipio ?? ""}"
              data-agregado="${p.agregado ?? ""}"
              data-zona="${p.zona ?? ""}"
              data-poligono="${p.poligono ?? ""}"
              data-parcela="${p.parcela ?? ""}"
              data-recinto="${p.recinto ?? ""}"
              ${disabledAttr}
              style="
                padding: 6px 10px;
                font-size: 0.85rem;
                border-radius: 999px;
                border: none;
                background-color: #198754;
                color: white;
                cursor: pointer;
                ${disabledStyle}
              "
              onclick="window._solicitarRecintoDesdePopup(this)"
            >
              Añadir a mis recintos
            </button>
          </div>
        </div>
      `;

      layer.bindPopup(html);

      // Marcar visualmente la selección
      layer.on("click", function () {
        if (selectedRecintoLayer && selectedRecintoLayer !== layer) {
          selectedRecintoLayer.setStyle(RECINTO_STYLE_DEFAULT);
        }
        selectedRecintoLayer = layer;
        layer.setStyle(RECINTO_STYLE_SELECTED);
        layer.openPopup();
      });
    },
  }).addTo(map);

  const MIS_RECINTO_STYLE = {
    color: "#00a86b",
    weight: 5,
    opacity: 1,
    fillColor: "#00a86b",
    fillOpacity: 0.22,
  };

  const misRecintosLayer = L.geoJSON(null, {
    pane: 'misPane',
    style: () => MIS_RECINTO_STYLE,
  }).addTo(map);

  // Por defecto activos
  let misRecintosActivos = true;

  function cargarMisRecintosSiProcede() {
    const z = map.getZoom();

    if (z < ZOOM_RECINTOS || !misRecintosActivos) {
      misRecintosLayer.clearLayers();
      return;
    }

    const b = map.getBounds();
    const bbox = [
      b.getWest().toFixed(6),
      b.getSouth().toFixed(6),
      b.getEast().toFixed(6),
      b.getNorth().toFixed(6),
    ].join(",");

    fetch(`/api/mis-recintos?bbox=${bbox}`)
      .then((r) => {
        if (!r.ok) throw new Error("Respuesta no OK de /api/mis-recintos");
        return r.json();
      })
      .then((fc) => {
        misRecintosLayer.clearLayers();
        if (fc && fc.features && fc.features.length) {
          misRecintosLayer.addData(fc);
        }
      })
      .catch((err) => console.error("Error al cargar mis recintos:", err));
  }

  // *** Recintos activos por defecto ***
  let recintosActivos = true;

  // Función auxiliar para llamar a la API de solicitudes
  function solicitarRecinto(payload) {
    fetch("/api/solicitudes-recinto", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    })
      .then((response) => response.json().catch(() => ({})))
      .then((data) => {
        if (data && data.ok) {
          NotificationSystem.show({
            type: 'success',
            title: '¡Solicitud enviada!',
            message: 'Tu solicitud ha sido enviada al administrador correctamente.'
          });
        } else {
          const msg = (data && data.error) || "No se ha podido crear la solicitud. ¿Estás identificado?";
          console.error("Error en la respuesta de la API:", data);

          NotificationSystem.show({
            type: 'error',
            title: 'Error en la solicitud',
            message: msg
          });
        }
      })
      .catch((err) => {
        console.error("Error al crear la solicitud de recinto:", err);

        NotificationSystem.show({
          type: 'warning',
          title: 'Error de comunicación',
          message: 'No se pudo conectar con el servidor. Por favor, intenta de nuevo.'
        });
      });
  }

  // Handler global llamado desde el botón del popup
  window._solicitarRecintoDesdePopup = function (btn) {
    if (!btn || btn.disabled) return;

    const ds = btn.dataset;
    console.log("Solicitud de recinto desde popup:", ds);

    const payload = {
      id_recinto: ds.idrecinto || null,
      provincia: ds.provincia ? Number(ds.provincia) : null,
      municipio: ds.municipio ? Number(ds.municipio) : null,
      agregado: ds.agregado ? Number(ds.agregado) : null,
      zona: ds.zona ? Number(ds.zona) : null,
      poligono: ds.poligono ? Number(ds.poligono) : null,
      parcela: ds.parcela ? Number(ds.parcela) : null,
      recinto: ds.recinto ? Number(ds.recinto) : null,
    };

    solicitarRecinto(payload);
  };

  // -----------------------------------------
  // 5) Cargar recintos
  // -----------------------------------------
  function cargarRecintosSiProcede() {
    const z = map.getZoom();

    if (z < ZOOM_RECINTOS || !recintosActivos) {
      recintosLayer.clearLayers();
      return;
    }

    const b = map.getBounds();
    const bbox = [
      b.getWest().toFixed(6),
      b.getSouth().toFixed(6),
      b.getEast().toFixed(6),
      b.getNorth().toFixed(6),
    ].join(",");

    console.log("Solicitando recintos para bbox:", bbox);

    fetch(`/api/recintos?bbox=${bbox}`)
      .then((response) => {
        if (!response.ok) {
          throw new Error("Respuesta no OK de /api/recintos");
        }
        return response.json();
      })
      .then((fc) => {
        console.log("Recintos recibidos:", fc && fc.features ? fc.features.length : 0);
        recintosLayer.clearLayers();
        if (!fc || !fc.features || fc.features.length === 0) {
          return;
        }
        recintosLayer.addData(fc);
      })
      .catch((err) => {
        console.error("Error al cargar recintos:", err);
      });
  }

  // -----------------------------------------
  // 6) Actualizar mapa según zoom
  // -----------------------------------------
  function actualizarMapaSegunZoom() {
    const z = map.getZoom();
    const activeHighLayer = getActiveHighLayer();

    if (z >= ZOOM_RECINTOS) {
      if (map.hasLayer(baseOSM)) {
        map.removeLayer(baseOSM);
      }

      Object.values(highZoomLayers).forEach((layer) => {
        if (layer && layer !== activeHighLayer && map.hasLayer(layer)) {
          map.removeLayer(layer);
        }
      });

      if (activeHighLayer && !map.hasLayer(activeHighLayer)) {
        activeHighLayer.addTo(map);
      }
    } else {
      Object.values(highZoomLayers).forEach((layer) => {
        if (layer && map.hasLayer(layer)) {
          map.removeLayer(layer);
        }
      });

      if (!map.hasLayer(baseOSM)) {
        baseOSM.addTo(map);
      }

      recintosLayer.clearLayers();
    }
  }

  // -----------------------------------------
  // 7) Eventos del mapa
  // -----------------------------------------

  map.on("zoomend", () => {
    actualizarMapaSegunZoom();
    cargarRecintosSiProcede();
    cargarMisRecintosSiProcede();
  });

  map.on("moveend", () => {
    cargarRecintosSiProcede();
    cargarMisRecintosSiProcede();
  });

  actualizarMapaSegunZoom();
  cargarRecintosSiProcede();
  cargarMisRecintosSiProcede();

  // -----------------------------------------
  // 8) Lógica del panel y botones sincronizados
  // -----------------------------------------
  const toggleBtn = document.getElementById("basemap-toggle");
  const panel = document.getElementById("basemap-panel");
  const basemapContainer = document.getElementById("basemap-panel-container");
  const filtroContainer = document.getElementById("filtro-container");

  toggleBtn.addEventListener("click", () => {
    const isOpening = !panel.classList.contains("visible");

    panel.classList.toggle("visible");
    toggleBtn.classList.toggle("active");

    // Desplazar ambos contenedores
    if (isOpening) {
      basemapContainer.classList.add("panel-open");
      filtroContainer.classList.add("panel-open");
    } else {
      basemapContainer.classList.remove("panel-open");
      filtroContainer.classList.remove("panel-open");
    }
  });

  // --- Selección de mapa principal ---
  document
    .querySelectorAll(".basemap-option.basemap-main[data-layer]")
    .forEach((option) => {
      option.addEventListener("click", () => {
        const layerKey = option.dataset.layer;
        if (!highZoomLayers[layerKey]) {
          return;
        }

        document
          .querySelectorAll(".basemap-option.basemap-main")
          .forEach((el) => el.classList.remove("active"));
        option.classList.add("active");

        activeHighLayerKey = layerKey;
        actualizarMapaSegunZoom();
      });
    });

  // --- Toggle Recintos SigPac ---
  const recintosOption = document.querySelector(
    '.basemap-option.basemap-detail[data-detail="sigpac"]'
  );

  if (recintosOption) {
    recintosOption.addEventListener("click", () => {
      recintosActivos = !recintosActivos;

      if (recintosActivos) {
        recintosOption.classList.add("active");
        cargarRecintosSiProcede();
      } else {
        recintosOption.classList.remove("active");
        recintosLayer.clearLayers();
      }
    });
  }

  // --- Toggle MisRecintos ---
  const misRecintosOption = document.querySelector(
    '.basemap-option.basemap-detail[data-detail="mis"]'
  );

  if (misRecintosOption) {
    misRecintosOption.addEventListener("click", () => {
      misRecintosActivos = !misRecintosActivos;

      if (misRecintosActivos) {
        misRecintosOption.classList.add("active");
        cargarMisRecintosSiProcede();
      } else {
        misRecintosOption.classList.remove("active");
        misRecintosLayer.clearLayers();
      }
    });
  }


  // ============================================
  // CENTRAR EN RECINTO ESPECÍFICO
  // ============================================
  // Agregar esto al final del script, DENTRO del DOMContentLoaded, antes del último });

  // Recibir datos del recinto específico desde Flask
  const recintoData = {{ recinto_data| tojson | safe if recinto_data else 'null' }};

  // Variable para guardar la capa del recinto resaltado
  let recintoResaltado = null;

  // Función para limpieza de capa roja
  function clearHighlight() {
    if (recintoResaltado) {
      try {
        map.removeLayer(recintoResaltado); // Quita la capa roja
      } catch (e) {}
      recintoResaltado = null;
    }
  }

  // Función para centrar en un recinto específico
  function centrarEnRecinto(data) {
    if (!data) return;

    // Limpiar cualquier resaltado previo
    clearHighlight();

    console.log('Centrando en recinto:', data);

    try {
      // Parsear el GeoJSON del recinto
      const geojson = JSON.parse(data.geojson);

      // Crear el FeatureCollection completo
      const featureCollection = {
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          geometry: geojson,
          properties: {
            id_recinto: data.id,
            provincia: data.provincia,
            municipio: data.municipio,
            poligono: data.poligono,
            parcela: data.parcela,
            recinto: data.recinto,
            nombre: data.nombre,
            superficie_ha: data.superficie_ha,
            propietario: data.propietario
          }
        }]
      };

      // Función para abrir popup del recinto en la capa de recintos
      function openSigpacPopupForKey(key) {
        let targetLayer = null;

        recintosLayer.eachLayer((lyr) => {
          const p = (lyr.feature && lyr.feature.properties) || {};
          if (String(p.id_recinto) === String(key)) {
            targetLayer = lyr;
          }
        });

        if (targetLayer) {
          // simula comportamiento normal: seleccionar + abrir popup
          if (selectedRecintoLayer && selectedRecintoLayer !== targetLayer) {
            selectedRecintoLayer.setStyle(RECINTO_STYLE_DEFAULT);
          }
          selectedRecintoLayer = targetLayer;
          targetLayer.setStyle(RECINTO_STYLE_SELECTED);
          targetLayer.openPopup();
        }
      }

      // Guardar la clave del recinto rojo
      const highlightKey = String(data.id);

      // Crear la geometría con Leaflet con estilo destacado
      recintoResaltado = L.geoJSON(featureCollection, {
        pane: 'highlightPane',
        style: {
          color: '#FF0000',
          weight: 4,
          fillColor: '#FF6B6B',
          fillOpacity: 0.3,
          dashArray: '10, 5'
        }
      }).addTo(map);
      // asegurar arriba del todo
      recintoResaltado.bringToFront();

      // Crear contenido del popup
      const popupContent = `
      <div class="popup-recinto" style="min-width: 250px;">
        <div class="popup-recinto-info" style="font-size: 0.9rem;">
          <strong>Provincia:</strong> ${data.provincia}<br>
          <strong>Municipio:</strong> ${data.municipio}<br>
          <strong>Polígono:</strong> ${data.poligono}<br>
          <strong>Parcela:</strong> ${data.parcela}<br>
          <strong>Recinto:</strong> ${data.recinto}<br>
          <strong>Superficie:</strong> ${data.superficie_ha.toFixed(2)} ha<br>
          <strong>Propietario:</strong> ${data.propietario}
        </div>
      </div>
    `;

      // Añadir popup
      recintoResaltado.bindPopup(popupContent, {
        maxWidth: 300,
        className: 'recinto-destacado-popup'
      });

      // Quitar popup al cerrar
      map.on('popupclose', (e) => {
        if (!recintoResaltado) return;

        // Si el popup que se ha cerrado pertenece a la capa roja
        const src = e.popup && e.popup._source;
        const esDeResaltado =
          src && (recintoResaltado.hasLayer ? recintoResaltado.hasLayer(src) : false);

        if (esDeResaltado) {
          clearHighlight();
          openSigpacPopupForKey(highlightKey);
        }
      });

      // Cerrar popup al hacer clic en el recinto rojo
      recintoResaltado.eachLayer((lyr) => {
        lyr.on('click', () => {
          try { lyr.closePopup(); } catch (e) {}
        });
      });


      // Obtener bounds del recinto
      const bounds = recintoResaltado.getBounds();

      // Calcular el zoom apropiado
      const zoom = map.getBoundsZoom(bounds, false);
      const targetZoom = Math.min(zoom, 18); // Máximo zoom 18

      // Primero hacer zoom para que se cargue la capa correcta
      map.setView(bounds.getCenter(), Math.max(targetZoom, ZOOM_RECINTOS));

      // Después de un momento, ajustar el bounds con padding
      setTimeout(() => {
        map.fitBounds(bounds, {
          padding: [80, 80],
          maxZoom: 18,
          animate: true,
          duration: 0.5
        });

        // Abrir el popup después del zoom
        setTimeout(() => {
          recintoResaltado.openPopup();
        }, 600);
      }, 300);

    } catch (error) {
      console.error('Error al centrar en el recinto:', error);

      // Fallback: usar el bbox si falla el GeoJSON
      if (data.bbox && data.bbox.length === 4) {
        const [minx, miny, maxx, maxy] = data.bbox;
        const bounds = [[miny, minx], [maxy, maxx]];

        map.setView(
          [(miny + maxy) / 2, (minx + maxx) / 2],
          Math.max(ZOOM_RECINTOS, 16)
        );

        setTimeout(() => {
          map.fitBounds(bounds, {
            padding: [80, 80],
            maxZoom: 18
          });
        }, 300);
      }
    }
  }

  // Si hay datos de recinto, centrar en él cuando el mapa esté listo
  if (recintoData) {
    console.log('Recinto específico detectado, preparando centrado...');

    // Esperar a que el mapa esté completamente cargado
    map.whenReady(function () {
      console.log('Mapa listo, centrando en recinto...');

      // Activar recintos si están desactivados
      if (!recintosActivos) {
        recintosActivos = true;
        const recintosOption = document.querySelector(
          '.basemap-option.basemap-detail[data-detail="sigpac"]'
        );
        if (recintosOption) {
          recintosOption.classList.add('active');
        }
      }

      // Pequeño delay para asegurar que todo esté inicializado
      setTimeout(() => {
        centrarEnRecinto(recintoData);
      }, 500);
    });
  }


  if (recintoData) {
    // Crear control personalizado
    const RecentrarControl = L.Control.extend({
      options: {
        position: 'topleft'
      },

      onAdd: function (map) {
        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
        const button = L.DomUtil.create('a', '', container);

        button.href = '#';
        button.title = 'Volver a centrar en el recinto';
        button.innerHTML = '<i class="bi bi-crosshair" style="font-size: 18px; line-height: 30px;"></i>';
        button.style.width = '30px';
        button.style.height = '30px';
        button.style.lineHeight = '30px';
        button.style.display = 'flex';
        button.style.alignItems = 'center';
        button.style.justifyContent = 'center';
        button.style.backgroundColor = 'white';
        button.style.textDecoration = 'none';
        button.style.color = '#333';

        L.DomEvent.on(button, 'click', function (e) {
          L.DomEvent.stopPropagation(e);
          L.DomEvent.preventDefault(e);
          centrarEnRecinto(recintoData);
        });

        return container;
      }
    });

    map.addControl(new RecentrarControl());
  }

  const editarBtn = document.getElementById('editar-btn');
  const dibujarBtn = document.getElementById('dibujar-btn');
  const poligonoBtn = document.getElementById('poligono-btn');
  const aceptarBtn = document.getElementById('aceptar-btn');
  const cancelarBtn = document.getElementById('cancelar-btn');
  const limpiarBtn = document.getElementById('limpiar-btn');

  // FeatureGroup para guardar los elementos dibujados
  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  let rectangleDrawer = null;
  let polygonDrawer = null;
  let dibujosTemporales = [];

  // Al hacer clic en editar
  editarBtn.addEventListener('click', () => {
    editarBtn.classList.add('hidden');
    dibujarBtn.classList.remove('hidden');
    poligonoBtn.classList.remove('hidden');
    aceptarBtn.classList.remove('hidden');
    cancelarBtn.classList.remove('hidden');
    limpiarBtn.classList.remove('hidden');

    // Guardar estado actual
    dibujosTemporales = [];
    drawnItems.eachLayer(layer => {
      dibujosTemporales.push(layer);
    });

    console.log('Modo edición activado');
  });

  // Al hacer clic en dibujar rectángulo
  dibujarBtn.addEventListener('click', () => {
    // Desactivar polígono si está activo
    if (polygonDrawer) {
      polygonDrawer.disable();
      polygonDrawer = null;
    }

    // Crear y activar el dibujador de rectángulos
    rectangleDrawer = new L.Draw.Rectangle(map);
    rectangleDrawer.enable();

    console.log('Modo dibujo de rectángulo activado');
  });

  // Al hacer clic en dibujar polígono
  poligonoBtn.addEventListener('click', () => {
    // Desactivar rectángulo si está activo
    if (rectangleDrawer) {
      rectangleDrawer.disable();
      rectangleDrawer = null;
    }

    // Crear y activar el dibujador de polígonos
    polygonDrawer = new L.Draw.Polygon(map);
    polygonDrawer.enable();

    console.log('Modo dibujo de polígono activado - Haz clic para añadir puntos, doble clic para terminar');
  });

  // Evento cuando se completa el dibujo
  map.on(L.Draw.Event.CREATED, (e) => {
    const layer = e.layer;
    drawnItems.addLayer(layer);
    console.log('Forma dibujada:', layer);
  });

  // Al hacer clic en aceptar
  aceptarBtn.addEventListener('click', () => {
    dibujarBtn.classList.add('hidden');
    poligonoBtn.classList.add('hidden');
    aceptarBtn.classList.add('hidden');
    cancelarBtn.classList.add('hidden');
    limpiarBtn.classList.add('hidden');
    editarBtn.classList.remove('hidden');

    // Desactiva ambos modos de dibujo si están activos
    if (rectangleDrawer) {
      rectangleDrawer.disable();
      rectangleDrawer = null;
    }
    if (polygonDrawer) {
      polygonDrawer.disable();
      polygonDrawer = null;
    }

    console.log('Cambios guardados');
  });

  // Al hacer clic en cancelar
  cancelarBtn.addEventListener('click', () => {
    dibujarBtn.classList.add('hidden');
    poligonoBtn.classList.add('hidden');
    aceptarBtn.classList.add('hidden');
    cancelarBtn.classList.add('hidden');
    limpiarBtn.classList.add('hidden');
    editarBtn.classList.remove('hidden');

    // Desactiva ambos modos de dibujo
    if (rectangleDrawer) {
      rectangleDrawer.disable();
      rectangleDrawer = null;
    }
    if (polygonDrawer) {
      polygonDrawer.disable();
      polygonDrawer = null;
    }

    // Restaurar estado anterior (eliminar dibujos nuevos)
    drawnItems.clearLayers();
    dibujosTemporales.forEach(layer => {
      drawnItems.addLayer(layer);
    });

    console.log('Edición cancelada');
  });

  // Al hacer clic en limpiar
  limpiarBtn.addEventListener('click', () => {
    // Eliminar todos los dibujos
    drawnItems.clearLayers();
    console.log('Todos los dibujos eliminados');
  });
 
  });
</script>

{% endblock %}