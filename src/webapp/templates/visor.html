{% extends "base.html" %}

{% block title %}Visor SIG{% endblock %}

{% block navbar_extra %}
<div class="d-none d-md-flex align-items-center gap-3 bg-white rounded-3 px-3 py-2 shadow-sm">
  <!-- Temperatura principal -->
  <div class="d-flex align-items-center">
    <i class="bi bi-{{ weather.icono }} {{ weather.color_icono }}" style="font-size: 1.5rem;"></i>
    <span class="ms-2 fw-bold fs-5 text-dark">{{ weather.temperatura }}°</span>
  </div>

  <!-- Separador -->
  <div class="vr opacity-50"></div>

  <!-- Datos compactos -->
  <div class="d-flex gap-3 small text-dark">
    {% if weather.humedad %}
    <div class="d-flex align-items-center">
      <i class="bi bi-droplet-fill text-info me-1"></i>
      <span>{{ weather.humedad }}%</span>
    </div>
    {% endif %}

    {% if weather.viento_velocidad %}
    <div class="d-flex align-items-center">
      <i class="bi bi-wind text-secondary me-1"></i>
      <span>{{ weather.viento_velocidad }} km/h</span>
    </div>
    {% endif %}

    {% if weather.prob_precipitacion %}
    <div class="d-flex align-items-center">
      <i class="bi bi-cloud-rain text-primary me-1"></i>
      <span>{{ weather.prob_precipitacion }}%</span>
    </div>
    {% endif %}
  </div>

  <div class="d-none d-lg-block text-muted small">
    <i class="bi bi-geo-alt-fill"></i> {{ weather.municipio }}
  </div>
</div>
<div id="notification-container"></div>
{% endblock %}

{% block content %}


<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />

<style>
  /* El mapa ocupa toda la ventana menos la barra verde superior */
  html,
  body {
    height: 100%;
  }

  #editar-container {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 1000;
    font-family: inherit;
  }

  /* Botón flotante estilo basemap/filtro */
  #editar-btn {
    width: 48px;
    height: 48px;
    border-radius: 12px;
    border: none;
    background-color: #198754;
    /* mismo verde que otros botones */
    color: #ffffff;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition:
      background-color 0.2s ease,
      transform 0.16s ease-out,
      box-shadow 0.2s ease;
  }

  #editar-btn i {
    font-size: 22px;
  }

  #editar-btn:hover {
    transform: translateY(-1px) scale(1.04);
    box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
  }

  #editar-btn:active {
    transform: scale(0.96);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
  }


  #map {
    position: fixed;
    top: 65px;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
  }
  

  /* ---------- Contenedores de botones ---------- */
  #basemap-panel-container,
  #filtro-container {
    position: fixed;
    z-index: 1000;
    font-family: inherit;
    transition: right 0.25s ease-out;
  }

  #basemap-panel-container {
    top: 80px;
    right: 20px;
  }

  #filtro-container {
    top: 150px;
    right: 20px;
  }

  /* Cuando el panel de capas está abierto, ambos contenedores se desplazan */
  #basemap-panel-container.panel-open,
  #filtro-container.panel-open {
    right: 530px;
  }

  /* ---------- Botones flotantes ---------- */
  #basemap-toggle,
  #filtro-toggle {
    width: 48px;
    height: 48px;
    border-radius: 12px;
    border: none;
    background-color: #198754;
    color: #ffffff;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition:
      background-color 0.2s ease,
      transform 0.16s ease-out,
      box-shadow 0.2s ease;
  }

  #basemap-toggle i,
  #filtro-toggle i {
    font-size: 22px;
  }

  #basemap-toggle:not(.active),
  #filtro-toggle:not(.active) {
    background-color: #ffffff;
    color: #198754;
  }

  #basemap-toggle:hover,
  #filtro-toggle:hover {
    transform: translateY(-1px) scale(1.04);
    box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
  }

  #basemap-toggle:active,
  #filtro-toggle:active {
    transform: scale(0.96);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
  }

  #basemap-toggle.active,
  #filtro-toggle.active {
    background-color: #198754;
    color: #ffffff;
  }

  /* ---------- Panel ---------- */
  #basemap-panel {
    position: fixed;
    top: 80px;
    right: 20px;
    width: 420px;
    max-height: 75vh;
    background-color: #ffffff;
    box-shadow:
      0 10px 30px rgba(15, 23, 42, 0.35),
      0 1px 0 rgba(255, 255, 255, 0.5);
    border-radius: 18px;
    padding: 16px 20px 20px;
    overflow: hidden;
    opacity: 0;
    transform: translateX(100%) translateY(-8px);
    pointer-events: none;
    transition:
      transform 0.25s ease-out,
      opacity 0.22s ease-out;
    z-index: 999;
  }

  #basemap-panel.visible {
    opacity: 1;
    transform: translateX(-80px) translateY(0);
    pointer-events: auto;
  }

  #basemap-panel h6 {
    font-size: 1.15rem;
    font-weight: 700;
    margin-top: 10px;
    margin-bottom: 10px;
  }

  .basemap-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 14px;
    margin-bottom: 14px;
  }

  .basemap-option {
    width: 100%;
    cursor: pointer;
    text-align: center;
    font-size: 0.95rem;
    color: #333;
    transition:
      transform 0.18s ease-out,
      box-shadow 0.18s ease-out;
  }

  .basemap-thumb {
    width: 100%;
    height: 115px;
    border-radius: 12px;
    border: 3px solid transparent;
    position: relative;
    overflow: hidden;
    background-size: cover;
    background-position: center;
    margin-bottom: 6px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.20);
    transition:
      border-color 0.18s ease-out,
      box-shadow 0.18s ease-out,
      transform 0.18s ease-out;
  }

  .basemap-thumb img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }

  .basemap-option-label {
    line-height: 1.25;
    font-size: 0.9rem;
    font-weight: 500;
  }

  .basemap-option:not(.disabled):hover .basemap-thumb {
    transform: translateY(-2px);
    box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
  }

  .basemap-option:not(.disabled):hover {
    transform: translateY(-2px);
  }

  .basemap-option.active .basemap-thumb {
    border-color: #198754;
    border-width: 5px;
    box-shadow: 0 0 0 4px rgba(25, 135, 84, .25), 0 10px 22px rgba(0, 0, 0, .30);
    transform: translateY(-2px) scale(1.02);
  }

  .basemap-option.active .basemap-option-label {
    color: #198754;
    font-weight: 700;
  }

  .basemap-option.disabled {
    opacity: 0.45;
    cursor: default;
    pointer-events: none;
  }

  /* --------- Responsive: móviles / pantallas pequeñas ---------- */
  @media (max-width: 576px) {

    #basemap-panel-container,
    #filtro-container {
      right: 10px;
    }

    #basemap-panel-container.panel-open,
    #filtro-container.panel-open {
      right: 10px;
    }

    #basemap-panel {
      width: calc(100vw - 20px);
      right: 10px;
    }

    #basemap-panel.visible {
      transform: translateX(0) translateY(0);
    }

    .basemap-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  #notification-container {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10000;
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-width: 400px;
  }

  .notification {
    background: white;
    padding: 18px 20px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
    display: flex;
    align-items: flex-start;
    gap: 14px;
    animation: slideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    border-left: 4px solid;
    position: relative;
    overflow: hidden;
  }

  .notification.removing {
    animation: slideOut 0.3s ease forwards;
  }

  /* Animación centrada desde arriba */
  @keyframes slideIn {
    from {
      transform: translate(-50%, -40px);
      opacity: 0;
    }

    to {
      transform: translate(-50%, 0);
      opacity: 1;
    }
  }

  @keyframes slideOut {
    to {
      transform: translate(-50%, -40px);
      opacity: 0;
    }
  }

  .notification-icon {
    flex-shrink: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    font-weight: bold;
    font-size: 16px;
  }

  .notification-content {
    flex: 1;
  }

  .notification-title {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 4px;
    color: #1a1a1a;
  }

  .notification-message {
    font-size: 14px;
    color: #666;
    line-height: 1.4;
  }

  .notification-close {
    flex-shrink: 0;
    width: 20px;
    height: 20px;
    border: none;
    background: transparent;
    color: #999;
    cursor: pointer;
    font-size: 18px;
    line-height: 1;
    padding: 0;
    transition: color 0.2s;
  }

  .notification-close:hover {
    color: #333;
  }

  .notification-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 3px;
    background: currentColor;
    opacity: 0.3;
    animation: progress 5s linear forwards;
  }

  @keyframes progress {
    from {
      width: 100%;
    }

    to {
      width: 0%;
    }
  }

  /* Tipos */
  .notification.success {
    border-left-color: #198754;
  }

  .notification.success .notification-icon {
    background: #d1f4e0;
    color: #198754;
  }

  .notification.success .notification-progress {
    color: #198754;
  }

  .notification.error {
    border-left-color: #dc3545;
  }

  .notification.error .notification-icon {
    background: #f8d7da;
    color: #dc3545;
  }

  .notification.error .notification-progress {
    color: #dc3545;
  }

  .notification.warning {
    border-left-color: #ffc107;
  }

  .notification.warning .notification-icon {
    background: #fff3cd;
    color: #856404;
  }

  .notification.warning .notification-progress {
    color: #ffc107;
  }

  .notification.info {
    border-left-color: #0dcaf0;
  }

  .notification.info .notification-icon {
    background: #cff4fc;
    color: #055160;
  }

  .notification.info .notification-progress {
    color: #0dcaf0;
  }

  /* Responsive */
  @media (max-width: 576px) {
    #notification-container {
      left: 50%;
      right: auto;
      transform: translateX(-50%);
      top: 70px;
      max-width: calc(100% - 20px);
    }

    @keyframes slideIn {
      from {
        transform: translate(-50%, -60px);
        opacity: 0;
      }

      to {
        transform: translate(-50%, 0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      to {
        transform: translate(-50%, -60px);
        opacity: 0;
      }
    }

  }


  /* Dibujar? */
  .hidden {
    display: none !important;
  }

  #editar-container {
    display: flex;
    gap: 8px;
  }

  #editar-container button {
    border: none;
    padding: 10px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 18px;
    transition: all 0.3s ease;
  }

  #dibujar-btn {
    background: white;
    color: #28a745;
  }

  #poligono-btn {
    background: white;
    color: #28a745;
  }

  #aceptar-btn {
    background: #28a745;
    color: white;
  }

  #cancelar-btn {
    background: #dc3545;
    color: white;
  }

  #editar-container button:hover {
    opacity: 0.9;
    transform: scale(1.05);
  }

  /* ================================
   PANEL DERECHO (split)
  ================================ */

/* Ajuste correcto bajo la navbar SOLO en split */
  :root{
    --navbar-h: 65px;      /* fallback seguro */
    --side-panel-w: 0px;
  }

  body.split-mode{
    --side-panel-w: 40vw;
  }

  /* En split, el mapa deja hueco a la derecha y además respeta la navbar real */
  body.split-mode #map{
    top: var(--navbar-h);
    right: var(--side-panel-w);
    transition: right .25s ease-out, top .25s ease-out;
  }

  /* En normal, mantén tu top original (65px) */
  #map{
    top: 65px;
    transition: right .25s ease-out, top .25s ease-out;
  }

  /* Flotantes: siguen “pegados al mapa” a la derecha */
  body.split-mode #basemap-panel-container,
  body.split-mode #filtro-container,
  body.split-mode #editar-container,
  body.split-mode #basemap-panel{
    right: calc(20px + var(--side-panel-w));
    transition: right .25s ease-out;
  }

  /* Móvil: sin split */
  @media (max-width: 576px){
    body.split-mode{ --side-panel-w: 0px; }
    body.split-mode #map{ right: 0px; }
    body.split-mode #basemap-panel-container,
    body.split-mode #filtro-container,
    body.split-mode #editar-container,
    body.split-mode #basemap-panel{
      right: 10px;
    }
  }

  /* SPLIT: estilos del panel derecho */
  /* Panel derecho */
  #side-panel{
    position: fixed;
    top: 65px;           /* igual que el mapa */
    right: 0;
    bottom: 0;
    width: var(--side-panel-w);
    background: #fff;
    z-index: 950;        /* por encima del mapa */
    display: none;
    overflow: auto;
  }

  body.split-mode #side-panel{
    display: block;
  }

  /* Botón X */
  #side-close{
    position: absolute;
    top: 10px;
    right: 12px;

    width: 40px;
    height: 40px;

    border: 1px solid rgba(0,0,0,.2);
    border-radius: 8px;
    background: #fff;
    color: #111;

    display: flex;
    align-items: center;
    justify-content: center;

    padding: 0;
    line-height: 1;
    font-size: 26px;

    cursor: pointer;
    z-index: 2000;
  }

  #side-close:hover{
    background: #f8f9fa;
    border-color: #dc3545;
  }

  /* Contenido */
  .side-content{
    padding: 22px 22px 26px;
  }

  .side-header{
    position: relative;
    display: flex;
    align-items: center;
    justify-content: flex-end; /* acciones a la derecha */
    min-height: 52px;
    padding-right: 44px; /* aire para que no choque con la X */
  }

  #side-title{
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    margin: 0;
    text-align: center;
    max-width: calc(100% - 160px);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  #side-title[contenteditable="true"]{
    outline: 2px solid #0d6efd;
    border-radius: 4px;
    padding: 4px 8px;
  }

  .side-actions{
    display:flex;
    align-items:center;
    gap: 10px;
  }

  .icon-btn{
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 20px;
    line-height: 1;
    padding: 6px;
  }

  .icon-btn.edit{ color: #198754; }
  .icon-btn.delete{ color: #dc3545; }

  .side-divider{
    height: 2px;
    background: #111;
    opacity: .25;
    margin: 14px 0 18px;
    width: 100%;
  }

  .side-row{
    display:flex;
    gap: 12px;
    align-items:flex-start;
    padding: 10px 0;
    border-bottom: 1px solid rgba(0,0,0,.12);
  }

  .side-ico{
    font-size: 22px;
    color: #198754;
    margin-top: 2px;
  }

  .side-line{
    display:flex;
    align-items:baseline;
    gap: 10px;
  }

  .side-row-title{
    font-weight: 700;
    font-size: 20px;
  }

  .side-row-value{
    font-size: 20px;
    opacity: .85;
  }

  .side-row-text{
    display: flex;
    align-items: baseline;
    gap: 10px;
    flex-wrap: wrap;
  }

  /* Toggle */
  .side-toggle{
    display:flex;
    align-items:center;
    gap: 10px;
    margin-top: 16px;
    font-size: 18px;
    font-weight: 600;
  }
  .side-toggle input{
    width: 18px;
    height: 18px;
  }

</style>

<div id="map"></div>

<!-- Botón de capas -->
<div id="basemap-panel-container">
  <button id="basemap-toggle" title="Capas">
    <i class="bi bi-layers-fill"></i>
  </button>
</div>

<!-- Panel de capas -->
<div id="basemap-panel">
  <h6>Mapa Principal</h6>
  <div class="basemap-grid">
    <div class="basemap-option basemap-main active" data-layer="satellite">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_satellite.png') }}" alt="Imagen satélite" />
      </div>
      <div class="basemap-option-label">Imagen<br>Satelital</div>
    </div>

    <div class="basemap-option basemap-main" data-layer="ndvi">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_ndvi.png') }}" alt="Vigor Vegetal (NDVI)" />
      </div>
      <div class="basemap-option-label">Vigor Vegetal<br>(NDVI)</div>
    </div>

    <div class="basemap-option disabled">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_etp.png') }}" alt="ETP" />
      </div>
      <div class="basemap-option-label">ETP</div>
    </div>
  </div>

  <h6>Nivel de Detalle</h6>
  <div class="basemap-grid">
    <div class="basemap-option basemap-detail active" data-detail="mis">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_mis_recintos.png') }}" alt="Mis Recintos" />
      </div>
      <div class="basemap-option-label">Mis Recintos</div>
    </div>

    <div class="basemap-option basemap-detail active" data-detail="sigpac">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_recintos.png') }}" alt="Recintos SigPac" />
      </div>
      <div class="basemap-option-label">Recintos SigPac</div>
    </div>

    <div class="basemap-option disabled">
      <div class="basemap-thumb">
        <img src="{{ url_for('static', filename='img/thumb_cultivos.png') }}" alt="Cultivos SigPac" />
      </div>
      <div class="basemap-option-label">Cultivos SigPac</div>
    </div>
  </div>
</div>


<!-- Botón de filtros -->
<div id="filtro-container">
  <button id="filtro-toggle" title="Filtros">
    <i class="bi bi-funnel-fill"></i>
  </button>
</div>

<!-- Botón de dibujar -->
<div id="editar-container">
  <button id="dibujar-btn" class="hidden" title="Dibujar Rectángulo">
    <i class="bi bi-square"></i>
  </button>
  <button id="poligono-btn" class="hidden" title="Dibujar Polígono">
    <i class="bi bi-pentagon"></i>
  </button>
  <button id="editar-btn" title="Editar">
    <i class="bi bi-pencil-fill"></i>
  </button>
  <button id="aceptar-btn" class="hidden" title="Aceptar">
    <i class="bi bi-check-lg"></i>
  </button>
  <button id="limpiar-btn" class="hidden" title="Limpiar todo">
    <i class="bi bi-trash-fill"></i>
  </button>
  <button id="cancelar-btn" class="hidden" title="Cancelar">
    <i class="bi bi-x-lg"></i>
  </button>
</div>

<!-- Panel derecho (split) -->
<aside id="side-panel" aria-hidden="true">
  <button id="side-close" type="button" title="Cerrar">×</button>

  <div class="side-content">
    <div class="side-header">
      <h1 id="side-title">Nombre Parcela</h1>

      <div class="side-actions">
        <button id="btn-edit-name" type="button" class="icon-btn edit" title="Editar nombre">
          <i class="bi bi-pencil-fill"></i>
        </button>
        <button id="btn-delete-recinto" type="button" class="icon-btn delete" title="Eliminar recinto">
          <i class="bi bi-trash-fill"></i>
        </button>
      </div>
    </div>

    <div class="side-divider"></div>

  <div class="side-row">
    <i class="bi bi-globe2 side-ico"></i>
    <div class="side-line">
      <span class="side-row-title">Superficie:</span>
      <span id="side-area" class="side-row-value">-</span>
    </div>
  </div>

    <div class="side-row">
      <i class="bi bi-person-fill side-ico"></i>
      <div class="side-row-text">
        <div class="side-row-title">Propietario:</div>
        <div id="side-owner" class="side-row-value">-</div>
      </div>
    </div>

    <label class="side-toggle">
      <input id="side-active" type="checkbox" checked />
      <span>Recinto activo</span>
    </label>
  </div>
  <div id="side-alerts"></div>
</aside>

<script>
  const NotificationSystem = {
    container: null,
    initialized: false,

    init() {
      if (this.initialized) return;

      this.container = document.getElementById('notification-container');

      if (!this.container) {
        // Crear el contenedor si no existe
        this.container = document.createElement('div');
        this.container.id = 'notification-container';
        document.body.appendChild(this.container);
      
      } else {
      }
      this.initialized = true;
    },

    show({ type = 'info', title, message, duration = 5000 }) {
      // Inicializar si no está listo
      if (!this.initialized) {
        this.init();
      }

      if (!this.container) {
        console.error('❌ No se pudo crear el contenedor de notificaciones');
        // Fallback a alert
        alert(`${title}\n${message}`);
        return;
      }

      const notification = document.createElement('div');
      notification.className = `notification ${type}`;

      const icons = {
        success: '✓',
        error: '✕',
        warning: '⚠',
        info: 'i'
      };

      notification.innerHTML = `
        <div class="notification-icon">${icons[type]}</div>
        <div class="notification-content">
          <div class="notification-title">${this.escapeHtml(title)}</div>
          <div class="notification-message">${this.escapeHtml(message)}</div>
        </div>
        <button class="notification-close" aria-label="Cerrar">×</button>
        <div class="notification-progress"></div>
      `;

      // Evento de cierre
      const closeBtn = notification.querySelector('.notification-close');
      closeBtn.addEventListener('click', () => this.close(closeBtn));

      this.container.appendChild(notification);

      // Auto-cierre
      if (duration > 0) {
        setTimeout(() => {
          this.close(closeBtn);
        }, duration);
      }
    },

    close(button) {
      const notification = button.closest('.notification');
      if (!notification) return;

      notification.classList.add('removing');
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 300);
    },

    // Escapar HTML para prevenir XSS
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };

  // Función para establecer la variable CSS con la altura de la navbar
  function setNavbarHeightVar() {
    const navbar = document.querySelector("nav");
    if (!navbar) return;
    const h = navbar.getBoundingClientRect().height;
    document.documentElement.style.setProperty("--navbar-h", `${h}px`);
  }

  // calcular al cargar
  setNavbarHeightVar();

  // recalcular por si cambia (responsive)
  window.addEventListener("resize", setNavbarHeightVar);

  // -----------------------------------------
  // DOM Content Loaded
  // -----------------------------------------
  document.addEventListener("DOMContentLoaded", function () {

  const CURRENT_USER_ID = {{ current_user.id_usuario if current_user.is_authenticated else 'null' }};
  NotificationSystem.init();

  // -----------------------------------------
  // 1) ROI desde Flask
  // -----------------------------------------
  const roiBbox = [
    {{ roi_bbox[0] }},
    {{ roi_bbox[1] }},
    {{ roi_bbox[2] }},
    {{ roi_bbox[3] }}
  ];

  const ROI_BOUNDS = L.latLngBounds(
    [roiBbox[1], roiBbox[0]],
    [roiBbox[3], roiBbox[2]]
  );

  const ZOOM_RECINTOS = 15;

  // -----------------------------------------
  // 2) Crear mapa
  // -----------------------------------------
  const map = L.map("map", {
    maxBounds: ROI_BOUNDS,
    maxBoundsViscosity: 1.0,
    zoomControl: true,
  });

  map.fitBounds(ROI_BOUNDS);

  // --- Panes (orden de dibujo) ---
  map.createPane('sigpacPane');
  map.getPane('sigpacPane').style.zIndex = 400;

  map.createPane('misPane');
  map.getPane('misPane').style.zIndex = 450;

  map.createPane('highlightPane');
  map.getPane('highlightPane').style.zIndex = 650;

  // --- Modo split (panel derecho vacío) ---
  let splitOpen = false;

  function setSplitMode(on) {
    splitOpen = !!on;

    if (splitOpen) {
      setNavbarHeightVar(); // ✅ calcula SOLO al abrir split
    }

    document.body.classList.toggle("split-mode", splitOpen);

    setTimeout(() => {
      try { map.invalidateSize(); } catch (e) {}
    }, 280);
  }

  window.addEventListener('resize', () => {
    if (splitOpen) {
      setNavbarHeightVar();
      try { map.invalidateSize(); } catch (e) {}
    }
  });

  // Cerrar split
  const sideCloseBtn = document.getElementById("side-close");
  if (sideCloseBtn) {
    sideCloseBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();

      // 1) cerrar cualquier popup abierto
      try { map.closePopup(); } catch (_) {}

      // 2) quitar resaltado rojo
      clearHighlight();

      // 3) cerrar panel
      setSplitMode(false);

      // (opcional) reset id actual
      currentSideRecintoId = null;
    });
  }

  // ============================
  // EDITAR NOMBRE (lápiz)
  // Enter o blur => guardar
  // Escape => cancelar
  // ============================

  let currentSideRecintoId = null;
  let originalTitleText = "";

  const btnEdit = document.getElementById("btn-edit-name");
  const titleEl = document.getElementById("side-title");

  if (btnEdit && titleEl) {

    btnEdit.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();

      if (!currentSideRecintoId) {
        console.warn("No hay currentSideRecintoId");
        return;
      }

      originalTitleText = titleEl.textContent.trim();
      titleEl.setAttribute("contenteditable", "true");
      titleEl.focus();

      // Seleccionar todo el texto
      const range = document.createRange();
      range.selectNodeContents(titleEl);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    });

    titleEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        titleEl.blur();
      }

      if (e.key === "Escape") {
        e.preventDefault();
        titleEl.textContent = originalTitleText;
        titleEl.removeAttribute("contenteditable");
      }
    });

    titleEl.addEventListener("blur", async () => {
      titleEl.removeAttribute("contenteditable");

      const nuevoNombre = titleEl.textContent.trim();

      if (!nuevoNombre || nuevoNombre === originalTitleText) {
        titleEl.textContent = originalTitleText;
        return;
      }

      try {
        const r = await fetch(
          `/api/mis-recinto/${currentSideRecintoId}/nombre`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ nombre: nuevoNombre })
          }
        );

        if (!r.ok) throw new Error();

      } catch (err) {
        console.error(err);
        titleEl.textContent = originalTitleText;
        mostrarErrorInline("No se pudo guardar el nombre");
      }
    });

  }

  function safeText(v, fallback = "-") {
    if (v === null || v === undefined) return fallback;
    const s = String(v).trim();
    return s === "" ? fallback : s;
  }

  function parseBool(v, def = true) {
    if (v === undefined || v === null) return def;
    if (typeof v === "boolean") return v;
    if (typeof v === "number") return v !== 0;
    const s = String(v).toLowerCase().trim();
    if (["t","true","1","yes","y","si","sí"].includes(s)) return true;
    if (["f","false","0","no","n"].includes(s)) return false;
    return def;
  }

  function formatAreaHa(p) {
    const a = p.superficie_ha ?? p.superficie ?? p.area_ha ?? p.area ?? null;
    if (a === null || a === undefined || a === "") return "-";
    const n = Number(a);
    if (!Number.isFinite(n)) return safeText(a);
    return `${n.toFixed(2).replace(".", ",")} ha`;
  }

  function formatDateValue(v) {
    if (!v) return "-";
    const d = new Date(v);
    if (Number.isNaN(d.getTime())) return safeText(v);

    const dd = String(d.getDate()).padStart(2, "0");
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const yyyy = String(d.getFullYear());
    const hh = String(d.getHours()).padStart(2, "0");
    const min = String(d.getMinutes()).padStart(2, "0");
    return `${dd}/${mm}/${yyyy} ${hh}:${min}`;
  }

  function renderSidePanelFromProps(p) {
    currentSideRecintoId = p.id || p.id_recinto;
    document.getElementById("side-title").textContent = safeText(p.nombre, "Recinto");
    document.getElementById("side-area").textContent = (p.superficie_ha == null)
      ? "-"
      : `${Number(p.superficie_ha).toFixed(2).replace(".", ",")} ha`;
    document.getElementById("side-owner").textContent = safeText(p.propietario, "N/A");
    document.getElementById("side-active").checked = (p.activa == null) ? true : !!p.activa;
  }

  async function guardarNombreRecinto(nombre) {
    if (!currentSideRecintoId) return;

    try {
      const r = await fetch(
        `/api/mis-recinto/${currentSideRecintoId}/nombre`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ nombre })
        }
      );

      if (!r.ok) throw new Error();
    } catch (e) {
      mostrarErrorInline("No se pudo guardar el nombre");
    }
  }


    // CHECKBOX activo
    const sideActive = document.getElementById("side-active");
    if (sideActive) {
      sideActive.addEventListener("change", async () => {
        if (!currentSideRecintoId) return;

        const prev = !sideActive.checked; // estado anterior
        const next = sideActive.checked;

        sideActive.disabled = true;

        try {
          const r = await fetch(`/api/mis-recinto/${currentSideRecintoId}/activa`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ activa: next }),
          });

          const resp = await r.json().catch(() => ({}));
          if (!r.ok || !resp.ok) {
            throw new Error(resp.error || "No se pudo actualizar 'activa'");
          }

          // asegurar checkbox según backend
          sideActive.checked = !!resp.activa;

        } catch (err) {
          console.error(err);
          // revertir si falla
          sideActive.checked = prev;

          NotificationSystem.show({
            type: "error",
            title: "No se pudo guardar",
            message: "No se ha podido actualizar el estado del recinto. Intenta de nuevo."
          });
        } finally {
          sideActive.disabled = false;
        }
      });
    }


  // -----------------------------------------
  // 3) Capas base
  // -----------------------------------------
  const baseOSM = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    {
      attribution: "&copy; OpenStreetMap contributors",
      minZoom: 8,
      maxZoom: 19,
    }
  ).addTo(map);

  const baseSat = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    {
      attribution: "Tiles &copy; Esri",
      minZoom: 8,
      maxZoom: 19,
    }
  );

  const baseNdvi = L.imageOverlay(
    "/static/ndvi/ndvi_latest.png",
    ROI_BOUNDS,
    { opacity: 1.0 }
  );

  const highZoomLayers = {
    satellite: baseSat,
    ndvi: baseNdvi
  };

  let activeHighLayerKey = "satellite";
  function getActiveHighLayer() {
    return highZoomLayers[activeHighLayerKey];
  }

  // -----------------------------------------
  // 4) Capa de recintos
  // -----------------------------------------

  const RECINTO_STYLE_DEFAULT = {
    color: "#ff8800",
    weight: 1,
  };

  const RECINTO_STYLE_SELECTED = {
    color: "#0077ff",
    weight: 2,
    fillOpacity: 0.25,
  };

  let selectedRecintoLayer = null;

  const recintosLayer = L.geoJSON(null, {
    pane: 'sigpacPane',
    style: function () {
      return RECINTO_STYLE_DEFAULT;
    },
    onEachFeature: function (feature, layer) {
      const p = feature.properties || {};

      // Propietario: username o "N/A"
      const propietarioTexto =
        p.propietario && String(p.propietario).trim() !== ""
          ? p.propietario
          : "N/A";

      const tienePropietario = propietarioTexto !== "N/A";
      const disabledAttr = tienePropietario ? "disabled" : "";
      const disabledStyle = tienePropietario
        ? "opacity: 0.5; cursor: not-allowed;"
        : "";

      const html = `
        <div class="popup-recinto">
          <div class="popup-recinto-info">
            <strong>Provincia:</strong> ${p.provincia ?? "-"}<br>
            <strong>Municipio:</strong> ${p.municipio ?? "-"}<br>
            <strong>Polígono:</strong> ${p.poligono ?? "-"}<br>
            <strong>Parcela:</strong> ${p.parcela ?? "-"}<br>
            <strong>Recinto:</strong> ${p.recinto ?? "-"}<br>
            <strong>Propietario:</strong> ${propietarioTexto}
          </div>
          <div style="margin-top: 10px; text-align: right;">
            <button
              type="button"
              class="btn-add-recinto"
              data-id-recinto="${p.id_recinto ?? ""}"
              data-provincia="${p.provincia ?? ""}"
              data-municipio="${p.municipio ?? ""}"
              data-agregado="${p.agregado ?? ""}"
              data-zona="${p.zona ?? ""}"
              data-poligono="${p.poligono ?? ""}"
              data-parcela="${p.parcela ?? ""}"
              data-recinto="${p.recinto ?? ""}"
              ${disabledAttr}
              style="
                padding: 6px 10px;
                font-size: 0.85rem;
                border-radius: 999px;
                border: none;
                background-color: #198754;
                color: white;
                cursor: pointer;
                ${disabledStyle}
              "
              onclick="window._solicitarRecintoDesdePopup(this)"
            >
              Añadir a mis recintos
            </button>
          </div>
        </div>
      `;

      layer.bindPopup(html);

      // Marcar visualmente la selección
      layer.on("click", function () {
        if (selectedRecintoLayer && selectedRecintoLayer !== layer) {
          selectedRecintoLayer.setStyle(RECINTO_STYLE_DEFAULT);
        }
        selectedRecintoLayer = layer;
        layer.setStyle(RECINTO_STYLE_SELECTED);
        layer.openPopup();
      });
    },
  }).addTo(map);

  function openSigpacPopupForKey(key) {
    let targetLayer = null;

    recintosLayer.eachLayer((lyr) => {
      const p = (lyr.feature && lyr.feature.properties) || {};
      if (String(p.id_recinto) === String(key)) targetLayer = lyr;
    });

    if (!targetLayer) return false;

    if (selectedRecintoLayer && selectedRecintoLayer !== targetLayer) {
      selectedRecintoLayer.setStyle(RECINTO_STYLE_DEFAULT);
    }
    selectedRecintoLayer = targetLayer;
    targetLayer.setStyle(RECINTO_STYLE_SELECTED);
    targetLayer.openPopup();
    return true;
  }

  function openSigpacPopupForKeyWithRetry(key, tries = 12) {
    if (openSigpacPopupForKey(key)) return;
    if (tries <= 0) return;
    setTimeout(() => openSigpacPopupForKeyWithRetry(key, tries - 1), 250);
  }

  const MIS_RECINTO_STYLE = {
    color: "#00a86b",
    weight: 5,
    opacity: 1,
    fillColor: "#00a86b",
    fillOpacity: 0.22,
  };

  function setNavbarHeightVar() {
    // buscamos una navbar "real" (sticky/fixed)
    const candidates = [
      'nav.navbar.fixed-top',
      'nav.navbar.sticky-top',
      '.navbar.fixed-top',
      '.navbar.sticky-top',
      'header.fixed-top',
      'header.sticky-top',
      'nav'
    ];

    let el = null;
    for (const sel of candidates) {
      const found = document.querySelector(sel);
      if (!found) continue;

      const cs = window.getComputedStyle(found);
      const pos = cs.position;
      // solo nos vale si realmente está fija o sticky
      if (pos === 'fixed' || pos === 'sticky') {
        el = found;
        break;
      }
    }

    let h = 65; // fallback
    if (el) {
      // bottom es mejor que height porque incluye padding/border y evita cosas raras
      const rect = el.getBoundingClientRect();
      h = Math.round(rect.bottom);
    }

    // clamp: si sale algo absurdo, volvemos al fallback
    if (h < 40 || h > 120) h = 65;

    document.documentElement.style.setProperty('--navbar-h', `${h}px`);
  }

  async function abrirRecintoEnPanel(data) {
    if (!data || !data.id) return;

    // abrir split
    setSplitMode(true);

    // setear id global
    currentSideRecintoId = data.id;

    // pintar panel
    renderSidePanelFromProps(data);

    // centrar y resaltar
    centrarEnRecinto(data);
  }

  async function abrirRecintoDesdeVer(dataFlask) {
    if (!dataFlask || !dataFlask.id) return;

    // Siempre centramos y resaltamos en rojo
    centrarEnRecinto(dataFlask);

    // Comprobar si es mío intentando pedir detalle "mis-recinto"
    try {
      const r = await fetch(`/api/mis-recinto/${dataFlask.id}`);
      if (!r.ok) throw new Error("No es mío");

      const dataDb = await r.json();

      // Es mío -> abrir panel con datos reales de BBDD
      setSplitMode(true);
      currentSideRecintoId = dataDb.id;
      renderSidePanelFromProps(dataDb);

    } catch (_) {
      // No es mío (admin u otro) -> NO abrir panel
      setSplitMode(false);
    }
  }

  async function abrirSidePanelSiEsMio(recintoId) {
    if (!recintoId) return false;

    try {
      const r = await fetch(`/api/mis-recinto/${recintoId}`);
      if (!r.ok) return false;

      const dataDb = await r.json();

      setSplitMode(true);
      currentSideRecintoId = dataDb.id;
      renderSidePanelFromProps(dataDb);

      return true;
    } catch (e) {
      return false;
    }
  }

  async function centrarYAbrirPanelSiEsMio(dataFlask) {
    if (!dataFlask || !dataFlask.id) return;
    centrarEnRecinto(dataFlask);
    await abrirSidePanelSiEsMio(dataFlask.id);
  }

  const misRecintosLayer = L.geoJSON(null, {
    pane: 'misPane',
    style: () => MIS_RECINTO_STYLE,
    onEachFeature: function (feature, layer) {
      layer.on("click", async function (e) {
        try { L.DomEvent.stop(e); } catch (_) {}

        const id = feature?.properties?.id_recinto;
        if (!id) return;

        try {
          const r = await fetch(`/api/mis-recinto/${id}`);
          if (!r.ok) throw new Error("No se pudo cargar detalle del recinto");
          const data = await r.json();

          abrirRecintoEnPanel(data);

        } catch (err) {
          console.error(err);
        }
      });
    }
  }).addTo(map);
    
  // Mis IDs para evitar duplicados
  const MIS_IDS = new Set();

  // Por defecto activos
  let misRecintosActivos = true;

  function cargarMisRecintosSiProcede() {
    const z = map.getZoom();

    if (z < ZOOM_RECINTOS || !misRecintosActivos) {
      misRecintosLayer.clearLayers();
      return;
    }

    const b = map.getBounds();
    const bbox = [
      b.getWest().toFixed(6),
      b.getSouth().toFixed(6),
      b.getEast().toFixed(6),
      b.getNorth().toFixed(6),
    ].join(",");

    fetch(`/api/mis-recintos?bbox=${bbox}`)
      .then((r) => {
        if (!r.ok) throw new Error("Respuesta no OK de /api/mis-recintos");
        return r.json();
      })
      .then((fc) => {
        misRecintosLayer.clearLayers();

        MIS_IDS.clear();
        if (fc && fc.features && fc.features.length) {
          fc.features.forEach(f => {
            const p = f.properties || {};
            if (p.id_recinto != null) MIS_IDS.add(String(p.id_recinto));
          });
          misRecintosLayer.addData(fc);
        }
      })
      .catch((err) => console.error("Error al cargar mis recintos:", err));
  }

  // *** Recintos activos por defecto ***
  let recintosActivos = true;

  // Función auxiliar para llamar a la API de solicitudes
  function solicitarRecinto(payload) {
    fetch("/api/solicitudes-recinto", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    })
      .then((response) => response.json().catch(() => ({})))
      .then((data) => {
        if (data && data.ok) {
          NotificationSystem.show({
            type: 'success',
            title: '¡Solicitud enviada!',
            message: 'Tu solicitud ha sido enviada al administrador correctamente.'
          });
        } else {
          const msg = (data && data.error) || "No se ha podido crear la solicitud. ¿Estás identificado?";
          console.error("Error en la respuesta de la API:", data);

          NotificationSystem.show({
            type: 'error',
            title: 'Error en la solicitud',
            message: msg
          });
        }
      })
      .catch((err) => {
        console.error("Error al crear la solicitud de recinto:", err);

        NotificationSystem.show({
          type: 'warning',
          title: 'Error de comunicación',
          message: 'No se pudo conectar con el servidor. Por favor, intenta de nuevo.'
        });
      });
  }

  // Función auxiliar para mensajes tipo bootstrap
  function mostrarErrorInline(msg) {
    const c = document.getElementById("side-alerts");
    if (!c) return;

    c.innerHTML = `
      <div class="alert alert-danger alert-dismissible fade show" role="alert">
        ${msg}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      </div>
    `;
  }

  // Handler global llamado desde el botón del popup
  window._solicitarRecintoDesdePopup = function (btn) {
    if (!btn || btn.disabled) return;

    const ds = btn.dataset;

    const payload = {
      id_recinto: ds.idrecinto || null,
      provincia: ds.provincia ? Number(ds.provincia) : null,
      municipio: ds.municipio ? Number(ds.municipio) : null,
      agregado: ds.agregado ? Number(ds.agregado) : null,
      zona: ds.zona ? Number(ds.zona) : null,
      poligono: ds.poligono ? Number(ds.poligono) : null,
      parcela: ds.parcela ? Number(ds.parcela) : null,
      recinto: ds.recinto ? Number(ds.recinto) : null,
    };

    solicitarRecinto(payload);
  };

  // -----------------------------------------
  // 5) Cargar recintos
  // -----------------------------------------
  function cargarRecintosSiProcede() {
    const z = map.getZoom();

    if (z < ZOOM_RECINTOS || !recintosActivos) {
      recintosLayer.clearLayers();
      return;
    }

    const b = map.getBounds();
    const bbox = [
      b.getWest().toFixed(6),
      b.getSouth().toFixed(6),
      b.getEast().toFixed(6),
      b.getNorth().toFixed(6),
    ].join(",");

    console.log("Solicitando recintos para bbox:", bbox);

    fetch(`/api/recintos?bbox=${bbox}`)
      .then((response) => {
        if (!response.ok) {
          throw new Error("Respuesta no OK de /api/recintos");
        }
        return response.json();
      })
      .then((fc) => {
        console.log("Recintos recibidos:", fc && fc.features ? fc.features.length : 0);
        recintosLayer.clearLayers();
        if (!fc || !fc.features || fc.features.length === 0) {
          return;
        }
        recintosLayer.addData(fc);
      })
      .catch((err) => {
        console.error("Error al cargar recintos:", err);
      });
  }

  // -----------------------------------------
  // 6) Actualizar mapa según zoom
  // -----------------------------------------
  function actualizarMapaSegunZoom() {
    const z = map.getZoom();
    const activeHighLayer = getActiveHighLayer();

    if (z >= ZOOM_RECINTOS) {
      if (map.hasLayer(baseOSM)) {
        map.removeLayer(baseOSM);
      }

      Object.values(highZoomLayers).forEach((layer) => {
        if (layer && layer !== activeHighLayer && map.hasLayer(layer)) {
          map.removeLayer(layer);
        }
      });

      if (activeHighLayer && !map.hasLayer(activeHighLayer)) {
        activeHighLayer.addTo(map);
      }
    } else {
      Object.values(highZoomLayers).forEach((layer) => {
        if (layer && map.hasLayer(layer)) {
          map.removeLayer(layer);
        }
      });

      if (!map.hasLayer(baseOSM)) {
        baseOSM.addTo(map);
      }

      recintosLayer.clearLayers();
    }
  }

  // -----------------------------------------
  // 7) Eventos del mapa
  // -----------------------------------------

  map.on("zoomend", () => {
    actualizarMapaSegunZoom();
    cargarRecintosSiProcede();
    cargarMisRecintosSiProcede();
  });

  map.on("moveend", () => {
    cargarRecintosSiProcede();
    cargarMisRecintosSiProcede();
  });

  actualizarMapaSegunZoom();
  cargarRecintosSiProcede();
  cargarMisRecintosSiProcede();

  // -----------------------------------------
  // 8) Lógica del panel y botones sincronizados
  // -----------------------------------------
  const toggleBtn = document.getElementById("basemap-toggle");
  const panel = document.getElementById("basemap-panel");
  const basemapContainer = document.getElementById("basemap-panel-container");
  const filtroContainer = document.getElementById("filtro-container");

  toggleBtn.addEventListener("click", () => {
    const isOpening = !panel.classList.contains("visible");

    panel.classList.toggle("visible");
    toggleBtn.classList.toggle("active");

    // Desplazar ambos contenedores
    if (isOpening) {
      basemapContainer.classList.add("panel-open");
      filtroContainer.classList.add("panel-open");
    } else {
      basemapContainer.classList.remove("panel-open");
      filtroContainer.classList.remove("panel-open");
    }
  });

  // --- Selección de mapa principal ---
  document
    .querySelectorAll(".basemap-option.basemap-main[data-layer]")
    .forEach((option) => {
      option.addEventListener("click", () => {
        const layerKey = option.dataset.layer;
        if (!highZoomLayers[layerKey]) {
          return;
        }

        document
          .querySelectorAll(".basemap-option.basemap-main")
          .forEach((el) => el.classList.remove("active"));
        option.classList.add("active");

        activeHighLayerKey = layerKey;
        actualizarMapaSegunZoom();
      });
    });

  // --- Toggle Recintos SigPac ---
  const recintosOption = document.querySelector(
    '.basemap-option.basemap-detail[data-detail="sigpac"]'
  );

  if (recintosOption) {
    recintosOption.addEventListener("click", () => {
      recintosActivos = !recintosActivos;

      if (recintosActivos) {
        recintosOption.classList.add("active");
        cargarRecintosSiProcede();
      } else {
        recintosOption.classList.remove("active");
        recintosLayer.clearLayers();
      }
    });
  }

  // --- Toggle MisRecintos ---
  const misRecintosOption = document.querySelector(
    '.basemap-option.basemap-detail[data-detail="mis"]'
  );

  if (misRecintosOption) {
    misRecintosOption.addEventListener("click", () => {
      misRecintosActivos = !misRecintosActivos;

      if (misRecintosActivos) {
        misRecintosOption.classList.add("active");
        cargarMisRecintosSiProcede();
      } else {
        misRecintosOption.classList.remove("active");
        misRecintosLayer.clearLayers();
      }
    });
  }


  // ============================================
  // CENTRAR EN RECINTO ESPECÍFICO
  // ============================================

  // Recibir datos del recinto específico desde Flask
  const recintoData = {{ recinto_data| tojson | safe if recinto_data else 'null' }};

  // Variable para guardar la capa del recinto resaltado
  let recintoResaltado = null;

  // Función para limpieza de capa roja
  function clearHighlight() {
    if (recintoResaltado) {
      try {
        map.removeLayer(recintoResaltado); // Quita la capa roja
      } catch (e) { }
      recintoResaltado = null;
    }
  }

  // Función para centrar en un recinto específico
  function centrarEnRecinto(data) {
    if (!data) return;

    // Limpiar cualquier resaltado previo
    clearHighlight();

    console.log('Centrando en recinto:', data);

    try {
      // Parsear el GeoJSON del recinto
      const geojson = JSON.parse(data.geojson);

      // Crear el FeatureCollection completo
      const featureCollection = {
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          geometry: geojson,
          properties: {
            id_recinto: data.id,
            provincia: data.provincia,
            municipio: data.municipio,
            poligono: data.poligono,
            parcela: data.parcela,
            recinto: data.recinto,
            nombre: data.nombre,
            superficie_ha: data.superficie_ha,
            propietario: data.propietario
          }
        }]
      };

      // Función para abrir popup del recinto en la capa de recintos
      function openSigpacPopupForKey(key) {
        let targetLayer = null;

        recintosLayer.eachLayer((lyr) => {
          const p = (lyr.feature && lyr.feature.properties) || {};
          if (String(p.id_recinto) === String(key)) {
            targetLayer = lyr;
          }
        });

        if (targetLayer) {
          const p = (targetLayer.feature && targetLayer.feature.properties) || {};
          const esMio = MIS_IDS.has(String(key));

          // Si es mío: NO abrir popup ni aplicar estilo azul
          if (esMio) {
            if (selectedRecintoLayer) {
              selectedRecintoLayer.setStyle(RECINTO_STYLE_DEFAULT);
              selectedRecintoLayer = null;
            }
            return; // no abrir popup si es mío
          }

          // Si NO es mío: comportamiento normal (abrir popup "Añadir a mis recintos")
          if (selectedRecintoLayer && selectedRecintoLayer !== targetLayer) {
            selectedRecintoLayer.setStyle(RECINTO_STYLE_DEFAULT);
          }
          selectedRecintoLayer = targetLayer;
          targetLayer.setStyle(RECINTO_STYLE_SELECTED);
          targetLayer.openPopup();
        }
      }

      // Guardar la clave del recinto rojo
      const highlightKey = String(data.id);

      // Crear la geometría con Leaflet con estilo destacado
      recintoResaltado = L.geoJSON(featureCollection, {
        pane: 'highlightPane',
        style: {
          color: '#FF0000',
          weight: 4,
          fillColor: '#FF6B6B',
          fillOpacity: 0.3,
          dashArray: '10, 5'
        }
      }).addTo(map);
      // asegurar arriba del todo
      recintoResaltado.bringToFront();

      // Crear contenido del popup
      const popupContent = `
      <div class="popup-recinto" style="min-width: 250px;">
        <div class="popup-recinto-info" style="font-size: 0.9rem;">
          <strong>Provincia:</strong> ${data.provincia}<br>
          <strong>Municipio:</strong> ${data.municipio}<br>
          <strong>Polígono:</strong> ${data.poligono}<br>
          <strong>Parcela:</strong> ${data.parcela}<br>
          <strong>Recinto:</strong> ${data.recinto}<br>
          <strong>Superficie:</strong> ${data.superficie_ha.toFixed(2)} ha<br>
          <strong>Propietario:</strong> ${data.propietario}
        </div>
      </div>
    `;

      // Añadir popup
      recintoResaltado.bindPopup(popupContent, {
        maxWidth: 300,
        className: 'recinto-destacado-popup'
      });

      // Cerrar popup al hacer clic en el recinto rojo
      recintoResaltado.eachLayer((lyr) => {
        lyr.on('click', () => {
          try { lyr.closePopup(); } catch (e) { }
        });
      });


      // Obtener bounds del recinto
      const bounds = recintoResaltado.getBounds();

      // Calcular el zoom apropiado
      const zoom = map.getBoundsZoom(bounds, false);
      const targetZoom = Math.min(zoom, 18); // Máximo zoom 18

      // Primero hacer zoom para que se cargue la capa correcta
      map.setView(bounds.getCenter(), Math.max(targetZoom, ZOOM_RECINTOS));

      // Después de un momento, ajustar el bounds con padding
      setTimeout(() => {
        map.fitBounds(bounds, {
          padding: [80, 80],
          maxZoom: 18,
          animate: true,
          duration: 0.5
        });

        // Abrir el popup después del zoom
        setTimeout(() => {
          recintoResaltado.openPopup();
        }, 600);
      }, 300);

    } catch (error) {
      console.error('Error al centrar en el recinto:', error);

      // Fallback: usar el bbox si falla el GeoJSON
      if (data.bbox && data.bbox.length === 4) {
        const [minx, miny, maxx, maxy] = data.bbox;
        const bounds = [[miny, minx], [maxy, maxx]];

        map.setView(
          [(miny + maxy) / 2, (minx + maxx) / 2],
          Math.max(ZOOM_RECINTOS, 16)
        );

        setTimeout(() => {
          map.fitBounds(bounds, {
            padding: [80, 80],
            maxZoom: 18
          });
        }, 300);
      }
    }
  }

  // Si hay datos de recinto, centrar en él cuando el mapa esté listo
  if (recintoData) {
    console.log('Recinto específico detectado, preparando centrado...');

    // Esperar a que el mapa esté completamente cargado
    map.whenReady(function () {
      console.log('Mapa listo, centrando en recinto...');

      // Activar recintos si están desactivados
      if (!recintosActivos) {
        recintosActivos = true;
        const recintosOption = document.querySelector(
          '.basemap-option.basemap-detail[data-detail="sigpac"]'
        );
        if (recintosOption) {
          recintosOption.classList.add('active');
        }
      }

      // Pequeño delay para asegurar que todo esté inicializado
      setTimeout(() => {
        abrirRecintoDesdeVer(recintoData);
      }, 300);
    });
  }


  if (recintoData) {
    // Crear control personalizado
    const RecentrarControl = L.Control.extend({
      options: {
        position: 'topleft'
      },

      onAdd: function (map) {
        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
        const button = L.DomUtil.create('a', '', container);

        button.href = '#';
        button.title = 'Volver a centrar en el recinto';
        button.innerHTML = '<i class="bi bi-crosshair" style="font-size: 18px; line-height: 30px;"></i>';
        button.style.width = '30px';
        button.style.height = '30px';
        button.style.lineHeight = '30px';
        button.style.display = 'flex';
        button.style.alignItems = 'center';
        button.style.justifyContent = 'center';
        button.style.backgroundColor = 'white';
        button.style.textDecoration = 'none';
        button.style.color = '#333';

        L.DomEvent.on(button, 'click', function (e) {
          L.DomEvent.stopPropagation(e);
          L.DomEvent.preventDefault(e);
          centrarYAbrirPanelSiEsMio(recintoData);
        });

        return container;
      }
    });

    map.addControl(new RecentrarControl());
  }

  const editarBtn = document.getElementById('editar-btn');
  const dibujarBtn = document.getElementById('dibujar-btn');
  const poligonoBtn = document.getElementById('poligono-btn');
  const aceptarBtn = document.getElementById('aceptar-btn');
  const cancelarBtn = document.getElementById('cancelar-btn');
  const limpiarBtn = document.getElementById('limpiar-btn');

  // FeatureGroup para guardar los elementos dibujados
  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  let rectangleDrawer = null;
  let polygonDrawer = null;
  let dibujosTemporales = [];

  // Al hacer clic en editar
  editarBtn.addEventListener('click', () => {
    editarBtn.classList.add('hidden');
    dibujarBtn.classList.remove('hidden');
    poligonoBtn.classList.remove('hidden');
    aceptarBtn.classList.remove('hidden');
    cancelarBtn.classList.remove('hidden');
    limpiarBtn.classList.remove('hidden');

    // Guardar estado actual
    dibujosTemporales = [];
    drawnItems.eachLayer(layer => {
      dibujosTemporales.push(layer);
    });

    console.log('Modo edición activado');
  });

  // Al hacer clic en dibujar rectángulo
  dibujarBtn.addEventListener('click', () => {
    // Desactivar polígono si está activo
    if (polygonDrawer) {
      polygonDrawer.disable();
      polygonDrawer = null;
    }

    // Crear y activar el dibujador de rectángulos
    rectangleDrawer = new L.Draw.Rectangle(map);
    rectangleDrawer.enable();

    console.log('Modo dibujo de rectángulo activado');
  });

  // Al hacer clic en dibujar polígono
  poligonoBtn.addEventListener('click', () => {
    // Desactivar rectángulo si está activo
    if (rectangleDrawer) {
      rectangleDrawer.disable();
      rectangleDrawer = null;
    }

    // Crear y activar el dibujador de polígonos
    polygonDrawer = new L.Draw.Polygon(map);
    polygonDrawer.enable();

    console.log('Modo dibujo de polígono activado - Haz clic para añadir puntos, doble clic para terminar');
  });

  // Evento cuando se completa el dibujo
  map.on(L.Draw.Event.CREATED, (e) => {
    const layer = e.layer;
    drawnItems.addLayer(layer);
    console.log('Forma dibujada:', layer);
  });

  // Al hacer clic en aceptar
  aceptarBtn.addEventListener('click', () => {
    dibujarBtn.classList.add('hidden');
    poligonoBtn.classList.add('hidden');
    aceptarBtn.classList.add('hidden');
    cancelarBtn.classList.add('hidden');
    limpiarBtn.classList.add('hidden');
    editarBtn.classList.remove('hidden');

    // Desactiva ambos modos de dibujo si están activos
    if (rectangleDrawer) {
      rectangleDrawer.disable();
      rectangleDrawer = null;
    }
    if (polygonDrawer) {
      polygonDrawer.disable();
      polygonDrawer = null;
    }

    console.log('Cambios guardados');
  });

  // Al hacer clic en cancelar
  cancelarBtn.addEventListener('click', () => {
    dibujarBtn.classList.add('hidden');
    poligonoBtn.classList.add('hidden');
    aceptarBtn.classList.add('hidden');
    cancelarBtn.classList.add('hidden');
    limpiarBtn.classList.add('hidden');
    editarBtn.classList.remove('hidden');

    // Desactiva ambos modos de dibujo
    if (rectangleDrawer) {
      rectangleDrawer.disable();
      rectangleDrawer = null;
    }
    if (polygonDrawer) {
      polygonDrawer.disable();
      polygonDrawer = null;
    }

    // Restaurar estado anterior (eliminar dibujos nuevos)
    drawnItems.clearLayers();
    dibujosTemporales.forEach(layer => {
      drawnItems.addLayer(layer);
    });

    console.log('Edición cancelada');
  });

  // Al hacer clic en limpiar
  limpiarBtn.addEventListener('click', () => {
    // Eliminar todos los dibujos
    drawnItems.clearLayers();
    console.log('Todos los dibujos eliminados');
  });
 
  });
</script>

{% endblock %}