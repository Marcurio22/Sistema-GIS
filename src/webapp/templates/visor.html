{% extends "base.html" %}

{% block content %}
<div class="container-fluid px-0">
  <div class="row g-0">
    <div class="col-12">
      <div id="map-wrapper">
        <div id="map"></div>
      </div>
    </div>
  </div>
</div>

<style>
  /* El mapa ocupa toda la altura visible menos la barra superior */
  #map-wrapper {
    height: calc(100vh - 56px); /* ajusta 56px si tu navbar mide otra cosa */
    width: 100%;
  }

  #map {
    height: 100%;
    width: 100%;
  }
</style>

<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha512-sA+e2at3wE0N+8n5M5wZ0pniS3pSke1Mt2rt7NmBGG99nmHn7+O+kO5OVwOB1p5MNDoAuCEr0aYawslrCe5sQ=="
  crossorigin=""
/>
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha512-vRmGQ9Cw8r6QfwZ0pniS3pSke1Mt2rt7NmBGG99nmHn7+O+kO5OVwOB1p5MNDoAuCEr0aYawslrCe5sQ=="
  crossorigin=""
></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    // -------------------------------
    // 1. Constantes de zoom y ROI
    // -------------------------------
    const ZOOM_INICIAL = 13;        // zoom de entrada
    const ZOOM_SATELITE = 15;       // a partir de aquí cambia a satélite
    const ZOOM_RECINTOS = 15;       // a partir de aquí se dibujan recintos

    // ROI enviada desde Flask (en EPSG:4326)
    const ROI_BOUNDS = [
      [{{ roi_bounds.miny }}, {{ roi_bounds.minx }}],   // [sur, oeste]
      [{{ roi_bounds.maxy }}, {{ roi_bounds.maxx }}]    // [norte, este]
    ];

    const ROI_CENTER = [
      {{ (roi_bounds.miny + roi_bounds.maxy) / 2 }},
      {{ (roi_bounds.minx + roi_bounds.maxx) / 2 }}
    ];

    // -------------------------------
    // 2. Crear mapa base
    // -------------------------------
    const map = L.map("map", {
      center: ROI_CENTER,
      zoom: ZOOM_INICIAL,
      minZoom: 10,
      maxZoom: 19
    });

    // Limitar navegación a la ROI
    const maxBounds = L.latLngBounds(ROI_BOUNDS);
    map.setMaxBounds(maxBounds);
    map.fitBounds(maxBounds);

    // -------------------------------
    // 3. Capas base
    // -------------------------------
    const osmLayer = L.tileLayer(
      "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      {
        maxZoom: 19,
        attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      }
    );

    // Esri World Imagery como "estilo Google Satellite"
    const satLayer = L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
      {
        maxZoom: 19,
        attribution:
          "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community"
      }
    );

    // Capa de recintos (vectorial)
    const recintosLayer = L.layerGroup();

    // Añadimos sólo la OSM al inicio
    osmLayer.addTo(map);

    // Control de capas (por si quieres cambiar manualmente)
    const baseLayers = {
      "Mapa callejero": osmLayer,
      "Satélite": satLayer
    };
    const overlays = {
      "Recintos SIGPAC": recintosLayer
    };
    L.control.layers(baseLayers, overlays, { collapsed: true }).addTo(map);

    // -------------------------------
    // 4. Función de descarga de recintos
    // -------------------------------
    function cargarRecintos() {
      const z = map.getZoom();

      // Si el zoom es pequeño, limpiamos y no pedimos nada
      if (z < ZOOM_RECINTOS) {
        recintosLayer.clearLayers();
        return;
      }

      const b = map.getBounds();
      const bbox = [
        b.getWest(),
        b.getSouth(),
        b.getEast(),
        b.getNorth()
      ].join(",");

      console.log("Solicitando recintos para bbox:", bbox);

      fetch(`/api/recintos?bbox=${bbox}`)
        .then((response) => {
          if (!response.ok) {
            throw new Error("Respuesta no OK de /api/recintos");
          }
          return response.json();
        })
        .then((fc) => {
          console.log(
            "Recintos recibidos:",
            fc && fc.features ? fc.features.length : 0
          );

          recintosLayer.clearLayers();

          if (!fc || !fc.features || fc.features.length === 0) {
            return;
          }

          const layer = L.geoJSON(fc, {
            style: {
              color: "#ff6600",
              weight: 1
            },
            onEachFeature: function (feature, layer) {
              const p = feature.properties || {};
              const html = `
                <strong>Provincia:</strong> ${p.provincia ?? "-"}<br>
                <strong>Municipio:</strong> ${p.municipio ?? "-"}<br>
                <strong>Polígono:</strong> ${p.poligono ?? "-"}<br>
                <strong>Parcela:</strong> ${p.parcela ?? "-"}<br>
                <strong>Recinto:</strong> ${p.recinto ?? "-"}
              `;
              layer.bindPopup(html);
            }
          });

          layer.addTo(recintosLayer);
        })
        .catch((err) => {
          console.error("Error al cargar recintos:", err);
        });
    }

    // -------------------------------
    // 5. Lógica de cambio de mapa y recintos según zoom
    // -------------------------------
    function actualizarCapasPorZoom() {
      const z = map.getZoom();

      // Cambio automático de mapa base
      if (z >= ZOOM_SATELITE) {
        if (map.hasLayer(osmLayer)) map.removeLayer(osmLayer);
        if (!map.hasLayer(satLayer)) map.addLayer(satLayer);
      } else {
        if (map.hasLayer(satLayer)) map.removeLayer(satLayer);
        if (!map.hasLayer(osmLayer)) map.addLayer(osmLayer);
      }

      // Mostrar / ocultar recintos
      if (z >= ZOOM_RECINTOS) {
        if (!map.hasLayer(recintosLayer)) {
          map.addLayer(recintosLayer);
        }
        cargarRecintos();
      } else {
        recintosLayer.clearLayers();
        if (map.hasLayer(recintosLayer)) {
          map.removeLayer(recintosLayer);
        }
      }
    }

    // Eventos
    map.on("zoomend", actualizarCapasPorZoom);
    map.on("moveend", function () {
      // Sólo recargar si estamos en zoom suficiente
      if (map.getZoom() >= ZOOM_RECINTOS) {
        cargarRecintos();
      }
    });

    // Primera configuración al entrar
    actualizarCapasPorZoom();
  });
</script>
{% endblock %}
