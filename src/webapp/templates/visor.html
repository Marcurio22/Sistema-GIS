{% extends "base.html" %}

{% block title %}Visor SIG{% endblock %}

{% block content %}

<!-- Leaflet CSS -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""
/>

<style>
  /* El mapa ocupa toda la ventana menos la barra verde superior */
  html,
  body {
    height: 100%;
  }

  #map {
    position: fixed;
    top: 56px; /* altura aproximada de la navbar; ajusta si hace falta */
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
  }
</style>

<div id="map"></div>

<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    // 1) BBOX del ROI inyectada desde Flask (lon/lat)
    // roi_bbox = (minx, miny, maxx, maxy)
    const roiBbox = [
      {{ roi_bbox[0] }},
      {{ roi_bbox[1] }},
      {{ roi_bbox[2] }},
      {{ roi_bbox[3] }},
    ];

    // Leaflet espera [lat, lng] -> [S,W] y [N,E]
    const roiBounds = L.latLngBounds(
      [roiBbox[1], roiBbox[0]], // (miny, minx) = sudoeste
      [roiBbox[3], roiBbox[2]]  // (maxy, maxx) = nordeste
    );

    // 2) Crear mapa limitado al ROI
    const map = L.map("map", {
      maxBounds: roiBounds,
      maxBoundsViscosity: 1.0, // rebote suave en los bordes
      zoomControl: true,
    });

    map.fitBounds(roiBounds);

    // 3) Capa base OSM
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap contributors",
      maxZoom: 19,
    }).addTo(map);

    // 4) Capa donde meteremos los recintos
    const recintosLayer = L.layerGroup().addTo(map);

    // 5) Función que pide recintos al backend según el BBOX del mapa
    function cargarRecintos() {
      const b = map.getBounds();

      const bbox = [
        b.getWest().toFixed(6),
        b.getSouth().toFixed(6),
        b.getEast().toFixed(6),
        b.getNorth().toFixed(6),
      ].join(",");

      console.log("Solicitando recintos para bbox:", bbox);

      fetch(`/api/recintos?bbox=${bbox}`)
        .then((response) => {
          if (!response.ok) {
            throw new Error("Respuesta no OK de /api/recintos");
          }
          return response.json();
        })
        .then((fc) => {
          console.log(
            "Recintos recibidos:",
            fc && fc.features ? fc.features.length : 0
          );

          recintosLayer.clearLayers();

          if (!fc || !fc.features || fc.features.length === 0) {
            return;
          }

          const layer = L.geoJSON(fc, {
            style: {
              color: "#ff0000",
              weight: 1,
            },
            onEachFeature: function (feature, layer) {
              const p = feature.properties || {};
              const html = `
                <strong>Provincia:</strong> ${p.provincia ?? "-"}<br>
                <strong>Municipio:</strong> ${p.municipio ?? "-"}<br>
                <strong>Polígono:</strong> ${p.poligono ?? "-"}<br>
                <strong>Parcela:</strong> ${p.parcela ?? "-"}<br>
                <strong>Recinto:</strong> ${p.recinto ?? "-"}
              `;
              layer.bindPopup(html);
            },
          });

          layer.addTo(recintosLayer);
        })
        .catch((err) => {
          console.error("Error al cargar recintos:", err);
        });
    }

    // 6) Cargar recintos al iniciar y cada vez que el usuario se mueve
    map.whenReady(cargarRecintos);
    map.on("moveend", cargarRecintos);
  });
</script>

{% endblock %}